<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arcane Idle: Wizard Tower</title>
  <style>
    :root {
      color-scheme: dark;
      --accent: #9f43ff;
      --accent-2: #1fb9ff;
      --gold: #ffcb67;
      --ember: #ff7e36;
      --text: #f7edcf;
      --muted: #c4b58f;
      --ok: #84efbb;
      --warn: #ffd479;
      --danger: #ff7f9e;
      --frame: #3e2a17;
      --frame-edge: #8a6533;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Trebuchet MS", "Segoe UI", system-ui, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 50% 15%, rgba(59, 85, 147, 0.55) 0%, transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(106, 51, 153, 0.4) 0%, transparent 28%),
        radial-gradient(circle at 15% 85%, rgba(163, 87, 28, 0.26) 0%, transparent 28%),
        linear-gradient(180deg, #17131d 0%, #0c0a10 100%);
      padding: 20px;
      letter-spacing: 0.02em;
    }

    .game {
      max-width: 1180px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 18px;
    }

    .panel {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.24)),
        radial-gradient(circle at 30% 0%, rgba(143, 84, 37, 0.25), transparent 35%),
        linear-gradient(180deg, #31241b, #24180f);
      border: 2px solid var(--frame-edge);
      border-radius: 12px;
      padding: 16px;
      backdrop-filter: blur(3px);
      box-shadow:
        inset 0 0 0 2px rgba(19, 12, 7, 0.7),
        0 12px 28px rgba(0, 0, 0, 0.45);
    }

    .wide { grid-column: 1 / -1; }

    h1, h2, h3 {
      margin: 0 0 10px;
      font-family: Georgia, "Times New Roman", serif;
      letter-spacing: 0.04em;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
    }

    h1 {
      font-size: 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .sub {
      color: var(--muted);
      font-size: 1rem;
      margin-bottom: 10px;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .stat {
      background: linear-gradient(180deg, rgba(22, 18, 12, 0.8), rgba(16, 12, 8, 0.94));
      border-radius: 10px;
      padding: 10px;
      border: 1px solid rgba(204, 147, 72, 0.42);
      box-shadow: inset 0 1px 0 rgba(255, 214, 135, 0.2);
    }

    .label { color: var(--muted); font-size: 0.82rem; }
    .value { font-size: 1.2rem; font-weight: 700; }

    button {
      width: 100%;
      border: 1px solid rgba(255, 204, 122, 0.65);
      border-radius: 10px;
      padding: 10px 12px;
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #7428d1, #43137f);
      color: white;
      cursor: pointer;
      font-weight: 700;
      transition: transform 0.08s ease, filter 0.15s ease;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.24),
        0 2px 8px rgba(0, 0, 0, 0.42);
      text-transform: uppercase;
    }

    button:hover:not(:disabled) { filter: brightness(1.08); }
    button:active:not(:disabled) { transform: scale(0.985); }
    button:disabled { cursor: not-allowed; opacity: 0.45; }

    .btn-secondary {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #215389, #15325f);
    }

    .btn-danger {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.12), transparent 40%),
        linear-gradient(135deg, #b6492e, #7f2214);
    }

    .shop {
      display: grid;
      gap: 10px;
      margin-top: 8px;
    }

    .upgrade-grid {
      grid-template-columns: repeat(auto-fill, minmax(86px, 1fr));
      gap: 12px;
      align-items: start;
    }

    .item {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 10px;
      align-items: center;
      background: linear-gradient(180deg, rgba(18, 13, 9, 0.9), rgba(43, 28, 16, 0.75));
      border-radius: 10px;
      border: 1px solid rgba(255, 196, 97, 0.28);
      padding: 10px;
    }

    .item-icon {
      width: 64px;
      height: 64px;
      border-radius: 10px;
      border: 1px solid rgba(255, 216, 147, 0.38);
      object-fit: cover;
      background: rgba(0, 0, 0, 0.35);
      box-shadow: 0 0 12px rgba(143, 67, 255, 0.4);
    }

    .upgrade-icon {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 12px;
      border: 1px solid rgba(255, 196, 97, 0.4);
      background: linear-gradient(180deg, rgba(18, 13, 9, 0.95), rgba(43, 28, 16, 0.8));
      padding: 8px;
      min-height: 86px;
      cursor: pointer;
      transition: transform 0.12s ease, border-color 0.12s ease;
    }

    .upgrade-icon:hover,
    .upgrade-icon:focus-visible {
      transform: translateY(-1px);
      border-color: rgba(255, 216, 147, 0.9);
      outline: none;
    }

    .upgrade-icon.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .upgrade-icon .item-icon {
      width: 56px;
      height: 56px;
      margin: 0;
    }

    .upgrade-tooltip {
      position: absolute;
      left: 50%;
      bottom: calc(100% + 12px);
      transform: translateX(-50%) translateY(0);
      width: min(320px, 78vw);
      padding: 12px 13px;
      border-radius: 10px;
      border: 1px solid rgba(255, 216, 147, 0.55);
      background: rgba(11, 8, 6, 0.97);
      color: #ffe7bf;
      font-size: 0.92rem;
      line-height: 1.35;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      z-index: 12;
      text-align: left;
    }

    .upgrade-tooltip b {
      display: block;
      margin-bottom: 6px;
      color: #fff6e0;
      font-size: 0.98rem;
    }

    .upgrade-icon:hover .upgrade-tooltip,
    .upgrade-icon:focus-visible .upgrade-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .upgrade-empty {
      color: var(--muted);
      padding: 10px;
      border-radius: 10px;
      border: 1px dashed rgba(255, 196, 97, 0.35);
      background: rgba(0, 0, 0, 0.2);
      text-align: center;
      font-size: 0.9rem;
    }

    .name { font-weight: 700; }
    .meta { color: var(--muted); font-size: 0.85rem; margin-top: 2px; }

    .pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(34, 110, 171, 0.4), rgba(26, 69, 112, 0.8));
      color: #9fddff;
      font-size: 0.8rem;
      margin-left: 4px;
      border: 1px solid rgba(159, 221, 255, 0.35);
    }

    .row { display: flex; gap: 10px; }
    .row button { flex: 1; }

    .buy-toggle {
      display: flex;
      border: 1px solid rgba(255, 202, 125, 0.5);
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
      background: rgba(0, 0, 0, 0.3);
    }

    .buy-toggle button {
      border-radius: 0;
      min-width: 58px;
      background: rgba(23, 14, 9, 0.85);
      font-weight: 600;
    }

    .buy-toggle .active {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #8f2adb, #57149d);
    }

    #log {
      height: 170px;
      overflow: auto;
      font-size: 0.9rem;
      background: rgba(8, 8, 8, 0.55);
      border-radius: 10px;
      padding: 8px;
      border: 1px solid rgba(255, 192, 106, 0.33);
      margin-top: 10px;
    }

    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
    .danger { color: var(--danger); }

    .tiny { font-size: 0.8rem; color: var(--muted); margin-top: 10px; }

    .resource-strips {
      margin-top: 12px;
      display: grid;
      gap: 8px;
    }

    .resource {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 233, 181, 0.35);
      background: linear-gradient(135deg, rgba(36, 22, 12, 0.95), rgba(59, 37, 21, 0.75));
      font-weight: 700;
    }

    .resource b {
      color: var(--gold);
    }

    .achievement-popups {
      position: fixed;
      right: 20px;
      bottom: 20px;
      display: grid;
      gap: 8px;
      z-index: 999;
      pointer-events: none;
    }

    .achievement-popup {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 220px;
      max-width: 300px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 196, 97, 0.4);
      background: linear-gradient(180deg, rgba(34, 19, 10, 0.95), rgba(14, 9, 5, 0.95));
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transform: translateY(6px);
      animation: popup-in 0.25s ease forwards;
    }

    .achievement-popup img {
      width: 34px;
      height: 34px;
      border-radius: 7px;
      border: 1px solid rgba(255, 216, 147, 0.4);
    }

    @keyframes popup-in {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }


    .spell-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .quickslot-bar {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(92px, 1fr));
      gap: 8px;
    }

    .quickslot {
      border: 1px solid rgba(255, 202, 125, 0.52);
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(36, 18, 41, 0.92), rgba(13, 10, 20, 0.95));
      color: var(--text);
      padding: 6px;
      display: grid;
      gap: 4px;
      align-items: center;
      justify-items: center;
      min-height: 74px;
    }

    .quickslot .slot-key {
      font-size: 0.72rem;
      color: var(--muted);
    }

    .quickslot img {
      width: 30px;
      height: 30px;
      border-radius: 7px;
      border: 1px solid rgba(186, 225, 255, 0.55);
      background: rgba(0, 0, 0, 0.35);
    }

    .quickslot .slot-cost {
      font-size: 0.72rem;
      color: var(--muted);
    }

    .quickslot.active {
      box-shadow: 0 0 0 2px rgba(159, 67, 255, 0.65) inset;
    }

    .spell-card {
      display: grid;
      gap: 8px;
      background: linear-gradient(180deg, rgba(16, 10, 6, 0.95), rgba(42, 22, 44, 0.7));
      border: 1px solid rgba(170, 127, 255, 0.48);
      border-radius: 12px;
      padding: 10px;
    }

    .spell-head {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .spell-icon {
      width: 58px;
      height: 58px;
      border-radius: 12px;
      border: 1px solid rgba(186, 225, 255, 0.55);
      box-shadow: 0 0 12px rgba(79, 174, 255, 0.45);
      background: rgba(0,0,0,0.35);
    }

    .spell-mini {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .scroll-shop {
      max-height: 320px;
      overflow: auto;
      padding-right: 4px;
      border: 1px solid rgba(255, 192, 106, 0.25);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.18);
    }

    @media (max-width: 900px) {
      .game { grid-template-columns: 1fr; }
      .stats { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>
<body>
  <main class="game">
    <section class="panel wide">
      <h1>
        <span>üßô Arcane Idle: Wizard Tower</span>
        <span class="pill">Idle + Clicker</span>
      </h1>
      <div class="sub">Gather power, train apprentices, and automate your magical empire with a richer fantasy HUD.</div>
      <div class="row">
        <button id="castBtn">‚ú® Cast <span id="activeSpellName">Arcane Bolt</span> (<span id="spellPower">+1 power</span>)</button>
        <button id="saveBtn" class="btn-secondary">üíæ Save</button>
        <button id="resetBtn" class="btn-danger">‚ôªÔ∏è Reset</button>
      </div>
      <div class="stats">
        <div class="stat"><div class="label">Power</div><div class="value" id="power">0</div></div>
        <div class="stat"><div class="label">Power / sec</div><div class="value" id="mps">0</div></div>
        <div class="stat"><div class="label">Arcane Rank</div><div class="value" id="rank">Novice</div></div>
        <div class="stat"><div class="label">Total Power Ever</div><div class="value" id="totalPower">0</div></div>
      </div>
      <div class="resource-strips">
        <div class="resource"><span>‚ö° Power Reserve</span><b id="powerMirror">0</b></div>
        <div class="resource"><span>üî∑ Spell Mana</span><b id="manaMirror">0</b></div>
      </div>
      <div class="tiny">Tip: Press <strong>Space</strong> to cast your selected spell using mana, or use <strong>1-5</strong> to cast spells directly from quickslots.</div>
    </section>


    <section class="panel wide">
      <h2>‚öîÔ∏è Spell Quickslots</h2>
      <div id="quickslots" class="quickslot-bar"></div>
    </section>

    <section class="panel">
      <h2>üîÆ Upgrades</h2>
      <div id="upgrades" class="shop scroll-shop upgrade-grid"></div>
    </section>

    <section class="panel">
      <h2>üß™ Structures</h2>
      <div class="buy-toggle" id="buyToggle">
        <button data-buy="1" class="active">x1</button>
        <button data-buy="10">x10</button>
        <button data-buy="25">x25</button>
      </div>
      <div id="structures" class="shop scroll-shop"></div>
    </section>


    <section class="panel">
      <h2>üèÜ Achievements</h2>
      <div id="achievements" class="shop scroll-shop"></div>
    </section>

    <section class="panel wide">
      <h2>üìú Event Log</h2>
      <div id="log"></div>
    </section>
  </main>

  <div id="achievementPopups" class="achievement-popups" aria-live="polite"></div>

  <script>
    const STORAGE_KEY = "arcane-idle-save-v2";
    const AUTO_SAVE_MS = 20000;


    function webIcon(glyph) {
      const codepoint = Array.from(glyph)
        .map((char) => char.codePointAt(0).toString(16))
        .filter((code) => code !== "fe0f")
        .join("-");
      return `https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/72x72/${codepoint}.png`;
    }

    const structureData = {
      apprentice: { name: "Apprentice", baseCost: 15, mps: 0.6, growth: 1.15, image: webIcon("üßô"), tooltip: "Apprentices channel basic mana streams and are your first source of passive mana income." },
      crystal: { name: "Mana Crystal", baseCost: 100, mps: 4, growth: 1.16, image: webIcon("üî∑"), tooltip: "Mana Crystals store ambient arcane power to sharply increase mana per second." },
      library: { name: "Enchanted Library", baseCost: 550, mps: 22, growth: 1.18, image: webIcon("üìö"), tooltip: "Enchanted Libraries unlock efficient spellcraft methods that multiply your idle gains." },
      golem: { name: "Arcane Golem", baseCost: 2600, mps: 95, growth: 1.2, image: webIcon("üóø"), tooltip: "Arcane Golems automate heavy magical labor and massively boost production." },
      observatory: { name: "Astral Observatory", baseCost: 11000, mps: 440, growth: 1.23, image: webIcon("üî≠"), tooltip: "Astral Observatories align your tower with leylines for elite mana generation." },
      manaForge: { name: "Mana Forge", baseCost: 42000, mps: 1650, growth: 1.24, image: webIcon("üî•"), tooltip: "A blazing forge that condenses raw arcana into high-output power cores." },
      portalNexus: { name: "Portal Nexus", baseCost: 140000, mps: 5200, growth: 1.26, image: webIcon("üåÄ"), tooltip: "Portal arrays siphon mana from nearby dimensions." },
      skyCitadel: { name: "Sky Citadel", baseCost: 420000, mps: 18000, growth: 1.27, image: webIcon("üè∞"), tooltip: "Floating mage-citadels create massive autonomous arcane output." },
      voidReactor: { name: "Void Reactor", baseCost: 1300000, mps: 63000, growth: 1.29, image: webIcon("üåå"), tooltip: "Harnesses dark-space turbulence for late-game production spikes." },
    };

    const upgradeData = {
      focusedWand: {
        name: "Focused Wand",
        cost: 60,
        effect: "Double Arcane Bolt power",
        school: "Arcane",
        image: webIcon("ü™Ñ"),
        tooltip: "Focused Wand strengthens each manual cast, making every click worth twice as much mana.",
        apply: (state) => state.clickPower *= 2,
      },
      dualChanneling: {
        name: "Dual Channeling",
        cost: 450,
        effect: "Arcane Bolt gains +8 power",
        school: "Arcane",
        image: webIcon("‚ú®"),
        tooltip: "Dual Channeling weaves two spells at once so each cast adds a large flat mana bonus.",
        apply: (state) => state.clickPower += 8,
      },
      runeEtching: {
        name: "Rune Etching",
        cost: 1200,
        effect: "All spell power +30%",
        school: "Arcane",
        image: webIcon("üîØ"),
        tooltip: "Arcane runes amplify the impact of every offensive cast.",
        apply: () => {},
      },
      manaCompression: {
        name: "Mana Compression",
        cost: 4200,
        effect: "Spell costs -20%",
        school: "Arcane",
        image: webIcon("üßø"),
        tooltip: "Dense mana channels reduce the mana needed to cast heavy spells.",
        apply: () => {},
      },
      leylineBinding: {
        name: "Leyline Binding",
        cost: 1400,
        effect: "All structures produce +25% mana",
        school: "Nature",
        image: webIcon("üß¨"),
        tooltip: "Leyline Binding anchors your tower to nearby leylines, increasing all structure output.",
        apply: () => {},
      },
      crystallizedThought: {
        name: "Crystallized Thought",
        cost: 6000,
        effect: "All structures produce +50% mana",
        school: "Mind",
        image: webIcon("üíé"),
        tooltip: "Crystallized Thought refines magical focus, delivering a major global boost to structures.",
        apply: () => {},
      },
      archmageSigil: {
        name: "Archmage Sigil",
        cost: 26000,
        effect: "All structures produce +120% mana",
        school: "Arcane",
        image: webIcon("üî±"),
        tooltip: "An ancient sigil that supercharges every mana engine in your empire.",
        apply: () => {},
      },
      tempestMastery: {
        name: "Tempest Mastery",
        cost: 90000,
        effect: "Lightning and Meteor spells +90% power",
        school: "Elemental",
        image: webIcon("‚ö°"),
        tooltip: "Mastery over storm magic dramatically boosts high-tier burst spells.",
        apply: () => {},
      },
      planarRefinery: {
        name: "Planar Refinery",
        cost: 350000,
        effect: "All structures produce +180% mana",
        school: "Void",
        image: webIcon("üè≠"),
        tooltip: "Distills planar residue into endless fuel for your late-game production chain.",
        apply: () => {},
      },
      celestialLattice: {
        name: "Celestial Lattice",
        cost: 1200000,
        effect: "All spell power +120%",
        school: "Celestial",
        image: webIcon("üå†"),
        tooltip: "Interlocks starlight and sigils so every spell detonates with vastly greater force.",
        apply: () => {},
      },
      singularityCore: {
        name: "Singularity Core",
        cost: 4500000,
        effect: "All structures produce +300% mana and spell costs -25%",
        school: "Void",
        image: webIcon("üï≥Ô∏è"),
        tooltip: "A compressed void-kernel that warps production and dramatically improves spell efficiency.",
        apply: () => {},
      },
      apprenticeTheory: {
        name: "Apprentice Theory",
        cost: 900,
        effect: "Unlocks scaling Arcane Study research",
        school: "Arcane",
        image: webIcon("üìú"),
        tooltip: "Inspired by Idle Wizard's layered upgrade trees: this opens repeatable spell research.",
        requirementText: "Reach 1,500 total power",
        requirement: (s) => s.totalPower >= 1500,
        apply: () => {},
      },
      arcaneStudy: {
        name: "Arcane Study",
        cost: 1500,
        effect: "+8% spell power per level",
        school: "Arcane",
        repeatable: true,
        growth: 1.7,
        image: webIcon("üìò"),
        tooltip: "A repeatable tome upgrade inspired by Idle Wizard's scaling upgrade purchases.",
        requirementText: "Learn Apprentice Theory",
        requirement: (s) => s.upgrades.apprenticeTheory,
        apply: () => {},
      },
      manaInfusion: {
        name: "Mana Infusion",
        cost: 4000,
        effect: "+6% structure output per level",
        school: "Elemental",
        repeatable: true,
        growth: 1.8,
        image: webIcon("üí†"),
        tooltip: "A scaling infusion line similar to long-form Idle Wizard enhancement chains.",
        requirementText: "Own 12 total structures",
        requirement: (s) => Object.values(s.structures).reduce((sum, amount) => sum + amount, 0) >= 12,
        apply: () => {},
      },
      ritualEconomy: {
        name: "Ritual Economy",
        cost: 9000,
        effect: "Spell costs -3% per level (cap 45%)",
        school: "Void",
        repeatable: true,
        growth: 2,
        image: webIcon("üïØÔ∏è"),
        tooltip: "Late-game spell efficiency research modeled after compounding upgrade systems.",
        requirementText: "Cast 80 spells",
        requirement: (s) => s.spellCasts >= 80,
        apply: () => {},
      },
    };

    const structureOrder = Object.keys(structureData);
    const structureUpgradeTiers = 5;
    for (const [index, structureKey] of structureOrder.entries()) {
      const structure = structureData[structureKey];
      const structureSlug = structure.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
      for (let tier = 1; tier <= structureUpgradeTiers; tier += 1) {
        const id = `${structureSlug}-amplifier-${tier}`;
        const unlockCount = (tier * 4) + (index * 2);
        const logarithmicScale = 1 + Math.log10(structure.baseCost * (tier + 2));
        const tierScale = Math.pow(tier + 1, 1.55);
        const cost = Math.floor(structure.baseCost * 18 * logarithmicScale * tierScale);
        const bonus = Number((0.12 + (Math.log2(tier + 1) * 0.11)).toFixed(3));

        upgradeData[id] = {
          name: `${structure.name} Amplifier ${tier}`,
          cost,
          effect: `${structure.name} output +${Math.round(bonus * 100)}%`,
          school: "Structure",
          image: structure.image,
          tooltip: `Logarithmic scaling enhancement focused on ${structure.name}. Boosts only this structure for targeted growth.`,
          requirementText: `Own ${unlockCount} ${structure.name}${unlockCount === 1 ? "" : "s"}`,
          requirement: (s) => s.structures[structureKey] >= unlockCount,
          structureTarget: structureKey,
          structureBonus: bonus,
          apply: () => {},
        };
      }
    }

    const spellData = {
      bolt: { name: "Arcane Bolt", basePower: 1, manaCost: 0, unlockAt: 0, image: webIcon("‚ú®") },
      fireball: { name: "Fireball", basePower: 40, manaCost: 30, unlockAt: 300, image: webIcon("üî•") },
      lightning: { name: "Chain Lightning", basePower: 175, manaCost: 120, unlockAt: 2500, image: webIcon("‚ö°") },
      meteor: { name: "Meteor Strike", basePower: 800, manaCost: 620, unlockAt: 14000, image: webIcon("üå†") },
      voidburst: { name: "Void Burst", basePower: 3200, manaCost: 2600, unlockAt: 70000, image: webIcon("üåÄ") },
    };

    const spellQuickslotOrder = ["bolt", "fireball", "lightning", "meteor", "voidburst"];

    const achievementData = [
      { key: "mana1k", name: "Power Hoarder I", image: webIcon("ü•â"), test: (s) => s.totalPower >= 1000, requirement: "Accumulate 1,000 total power from any source.", reward: "+5% structure output", tooltip: "First hoarding milestone. Keep casting and buying structures until lifetime power hits 1,000." },
      { key: "mana20k", name: "Power Hoarder II", image: webIcon("ü•à"), test: (s) => s.totalPower >= 20000, requirement: "Accumulate 20,000 total power over the run.", reward: "+10% structure output", tooltip: "Advanced hoarding milestone. Scale production and idle income to reach 20,000 lifetime power." },
      { key: "mana250k", name: "Power Hoarder III", image: webIcon("ü•á"), test: (s) => s.totalPower >= 250000, requirement: "Accumulate 250,000 total power.", reward: "+15% structure output", tooltip: "A mid-game mastery checkpoint that rewards sustained scaling." },
      { key: "mana2m", name: "Power Sovereign", image: webIcon("üëë"), test: (s) => s.totalPower >= 2000000, requirement: "Accumulate 2,000,000 total power.", reward: "+25% structure output", tooltip: "A late milestone for long sessions, requiring a truly automated tower." },
      { key: "golem3", name: "Golem Battalion", image: webIcon("üèÖ"), test: (s) => s.structures.golem >= 3, requirement: "Own 3 Arcane Golems at the same time.", reward: "+15 click power", tooltip: "Construct three Arcane Golems to earn this badge and permanently strengthen manual casting." },
      { key: "towerTycoon", name: "Tower Tycoon", image: webIcon("üèõÔ∏è"), test: (s) => Object.values(s.structures).reduce((sum, amount) => sum + amount, 0) >= 80, requirement: "Own 80 total structures.", reward: "+20% structure output", tooltip: "Rewards broad investment across your whole structure roster." },
      { key: "skyLord", name: "Lord of the Sky", image: webIcon("üè∞"), test: (s) => s.structures.skyCitadel >= 5, requirement: "Own 5 Sky Citadels.", reward: "+15% spell power", tooltip: "Your floating strongholds improve spell efficiency across all casts." },
      { key: "spellweaver", name: "Spellweaver", image: webIcon("üìò"), test: (s) => s.spellCasts >= 250, requirement: "Cast 250 spells in total.", reward: "-10% spell costs", tooltip: "Dedicated casting lowers spell maintenance costs permanently." },
      { key: "voidCaller", name: "Void Caller", image: webIcon("üåå"), test: (s) => s.structures.voidReactor >= 2, requirement: "Own 2 Void Reactors.", reward: "+40 click power", tooltip: "A deep-end milestone that empowers manual burst play in the late game." },
    ];

    const state = {
      power: 0,
      mana: 0,
      totalPower: 0,
      clickPower: 1,
      buyAmount: 1,
      activeSpell: "bolt",
      spellCasts: 0,
      structures: Object.fromEntries(Object.keys(structureData).map((k) => [k, 0])),
      upgrades: Object.fromEntries(Object.keys(upgradeData).map((k) => [k, 0])),
      achievements: Object.fromEntries(achievementData.map((a) => [a.key, false])),
      lastTick: Date.now(),
      lastSavedAt: null,
      log: [{ text: "Welcome, wizard. Your tower awaits.", klass: "" }],
    };

    const els = {
      power: document.getElementById("power"),
      totalPower: document.getElementById("totalPower"),
      mps: document.getElementById("mps"),
      rank: document.getElementById("rank"),
      powerMirror: document.getElementById("powerMirror"),
      manaMirror: document.getElementById("manaMirror"),
      activeSpellName: document.getElementById("activeSpellName"),
      spellPower: document.getElementById("spellPower"),
      achievementPopups: document.getElementById("achievementPopups"),
      castBtn: document.getElementById("castBtn"),
      quickslots: document.getElementById("quickslots"),
      saveBtn: document.getElementById("saveBtn"),
      resetBtn: document.getElementById("resetBtn"),
      buyToggle: document.getElementById("buyToggle"),
      structures: document.getElementById("structures"),
      upgrades: document.getElementById("upgrades"),
      achievements: document.getElementById("achievements"),
      log: document.getElementById("log"),
    };

    let previousUpgradeRenderKey = "";

    function format(num) {
      if (num < 1000) return num.toFixed(1).replace(/\.0$/, "");
      const units = ["K", "M", "B", "T", "Qa", "Qi"];
      let value = num;
      let idx = -1;
      while (value >= 1000 && idx < units.length - 1) {
        value /= 1000;
        idx += 1;
      }
      return `${value.toFixed(2)}${units[idx]}`;
    }

    function rankFromPower(totalPower) {
      if (totalPower >= 1200000) return "Grand Archmage";
      if (totalPower >= 300000) return "Archmage";
      if (totalPower >= 90000) return "Master";
      if (totalPower >= 20000) return "Adept";
      if (totalPower >= 3000) return "Scholar";
      if (totalPower >= 400) return "Initiate";
      return "Novice";
    }

    function addLog(message, klass = "") {
      const stamped = `[${new Date().toLocaleTimeString()}] ${message}`;
      state.log.unshift({ text: stamped, klass });
      state.log = state.log.slice(0, 90);
    }


    function upgradeLevel(key) {
      return Number(state.upgrades[key] || 0);
    }

    function hasUpgrade(key) {
      return upgradeLevel(key) > 0;
    }

    function getUpgradeCost(key) {
      const up = upgradeData[key];
      if (!up) return Infinity;
      const level = upgradeLevel(key);
      if (!up.repeatable && level > 0) return Infinity;
      const growth = up.growth || 1;
      return Math.floor(up.cost * Math.pow(growth, level));
    }

    function meetsUpgradeRequirement(key) {
      const up = upgradeData[key];
      if (!up || typeof up.requirement !== "function") return true;
      return up.requirement(state);
    }

    function getStructureCost(key, levelOffset = 0) {
      const data = structureData[key];
      const level = state.structures[key] + levelOffset;
      return Math.floor(data.baseCost * Math.pow(data.growth, level));
    }

    function getBulkStructureCost(key, amount) {
      let total = 0;
      for (let i = 0; i < amount; i += 1) {
        total += getStructureCost(key, i);
      }
      return total;
    }

    function productionMultiplier() {
      let mult = 1;
      if (hasUpgrade("leylineBinding")) mult *= 1.25;
      if (hasUpgrade("crystallizedThought")) mult *= 1.5;
      if (hasUpgrade("archmageSigil")) mult *= 2.2;
      if (hasUpgrade("planarRefinery")) mult *= 2.8;
      if (hasUpgrade("singularityCore")) mult *= 4;
      if (state.achievements.mana1k) mult *= 1.05;
      if (state.achievements.mana20k) mult *= 1.1;
      if (state.achievements.mana250k) mult *= 1.15;
      if (state.achievements.mana2m) mult *= 1.25;
      if (state.achievements.towerTycoon) mult *= 1.2;
      return mult;
    }

    function getStructureSpecificMultiplier(structureKey) {
      let mult = 1;
      for (const [upKey, level] of Object.entries(state.upgrades)) {
        if (!level) continue;
        const up = upgradeData[upKey];
        if (!up || up.structureTarget !== structureKey) continue;
        mult *= 1 + (up.structureBonus || 0);
      }
      return mult;
    }

    function getMps() {
      let total = 0;
      for (const [key, amount] of Object.entries(state.structures)) {
        total += amount * structureData[key].mps * getStructureSpecificMultiplier(key);
      }
      const infusionBonus = 1 + (upgradeLevel("manaInfusion") * 0.06);
      return total * productionMultiplier() * infusionBonus;
    }


    function spellCost(key) {
      const base = spellData[key].manaCost;
      const reduction = hasUpgrade("manaCompression") ? 0.8 : 1;
      const singularityDiscount = hasUpgrade("singularityCore") ? 0.75 : 1;
      const masteryDiscount = state.achievements.spellweaver ? 0.9 : 1;
      const ritualReduction = Math.max(0.55, 1 - (upgradeLevel("ritualEconomy") * 0.03));
      return Math.floor(base * reduction * singularityDiscount * masteryDiscount * ritualReduction);
    }

    function spellPower(key) {
      let power = spellData[key].basePower;
      if (key === "bolt") power = Math.max(power, state.clickPower);
      if (hasUpgrade("runeEtching")) power *= 1.3;
      if (hasUpgrade("tempestMastery") && (key === "lightning" || key === "meteor")) power *= 1.9;
      if (hasUpgrade("celestialLattice")) power *= 2.2;
      if (state.achievements.skyLord) power *= 1.15;
      power *= 1 + (upgradeLevel("arcaneStudy") * 0.08);
      return power;
    }

    function isSpellUnlocked(key) {
      return state.totalPower >= spellData[key].unlockAt;
    }

    function canAfford(cost) {
      return state.power >= cost;
    }

    function canAffordMana(cost) {
      return state.mana >= cost;
    }

    function buyStructure(key) {
      const amount = state.buyAmount;
      const totalCost = getBulkStructureCost(key, amount);
      if (!canAfford(totalCost)) return;

      state.power -= totalCost;
      state.structures[key] += amount;
      addLog(`Purchased ${amount} ${structureData[key].name}${amount > 1 ? "s" : ""}.`, "ok");
      render();
    }

    function buyUpgrade(key) {
      const up = upgradeData[key];
      if (!up || !meetsUpgradeRequirement(key)) return;
      const cost = getUpgradeCost(key);
      if (!canAfford(cost)) return;

      state.power -= cost;
      state.upgrades[key] = upgradeLevel(key) + 1;
      up.apply(state);
      previousUpgradeRenderKey = "";

      if (up.repeatable) {
        addLog(`Studied ${up.name} (Level ${upgradeLevel(key)}).`, "ok");
      } else {
        addLog(`Learned upgrade: ${up.name}. ${up.effect}`, "ok");
      }
      render();
    }

    function unlockAchievement(key) {
      if (state.achievements[key]) return;
      state.achievements[key] = true;
      const achievement = achievementData.find((a) => a.key === key);
      if (key === "golem3") state.clickPower += 15;
      if (key === "voidCaller") state.clickPower += 40;
      addLog(`Achievement unlocked: ${achievement.name} (${achievement.reward})`, "ok");
      showAchievementPopup(achievement);
    }

    function canClaimAchievement(key) {
      const achievement = achievementData.find((entry) => entry.key === key);
      if (!achievement || state.achievements[key]) return false;
      return achievement.test(state);
    }

    function claimAchievement(key) {
      if (!canClaimAchievement(key)) return;
      unlockAchievement(key);
      render();
    }

    function autoUnlockAchievements() {
      let changed = false;
      for (const achievement of achievementData) {
        if (!state.achievements[achievement.key] && achievement.test(state)) {
          unlockAchievement(achievement.key);
          changed = true;
        }
      }
      return changed;
    }

    function showAchievementPopup(achievement) {
      const popup = document.createElement("div");
      popup.className = "achievement-popup";
      popup.innerHTML = `
        <img src="${achievement.image}" alt="${achievement.name} icon" />
        <div>
          <strong>Achievement Unlocked</strong>
          <div>${achievement.name}</div>
        </div>
      `;
      els.achievementPopups.appendChild(popup);
      setTimeout(() => {
        popup.remove();
      }, 3200);
    }

    function castSpell(spellKey = state.activeSpell) {
      const key = spellData[spellKey] ? spellKey : "bolt";
      if (!isSpellUnlocked(key)) return;
      const cost = spellCost(key);
      if (!canAffordMana(cost)) return;

      const power = spellPower(key);
      state.mana -= cost;
      state.power += power;
      state.totalPower += power;
      state.spellCasts += 1;
      if (state.spellCasts % 25 === 0) {
        addLog(`Arcane rhythm! ${state.spellCasts} spells cast so far.`, "warn");
      }
      render();
    }

    function saveGame(showToast = true) {
      const payload = { ...state, totalMana: state.totalPower, power: state.power, mana: state.mana, lastTick: Date.now(), log: state.log.slice(0, 60) };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      state.lastSavedAt = Date.now();
      if (showToast) addLog("Game saved.", "ok");
      render();
    }

    function normalizeLoadedState(data) {
      state.power = Number((data.power ?? data.mana) || 0);
      state.mana = Number(data.mana || 0);
      state.totalPower = Number((data.totalPower ?? data.totalMana) || 0);
      state.clickPower = Number(data.clickPower || 1);
      state.buyAmount = [1, 10, 25].includes(Number(data.buyAmount)) ? Number(data.buyAmount) : 1;
      state.activeSpell = typeof data.activeSpell === "string" && spellData[data.activeSpell] ? data.activeSpell : "bolt";
      state.spellCasts = Number(data.spellCasts || 0);

      for (const key of Object.keys(state.structures)) {
        state.structures[key] = Number(data.structures?.[key] || 0);
      }
      for (const key of Object.keys(state.upgrades)) {
        const loaded = data.upgrades?.[key];
        state.upgrades[key] = loaded === true ? 1 : Number(loaded || 0);
      }
      previousUpgradeRenderKey = "";
      for (const key of Object.keys(state.achievements)) {
        state.achievements[key] = Boolean(data.achievements?.[key]);
      }

      state.log = Array.isArray(data.log) && data.log.length
        ? data.log.map((entry) => (typeof entry === "string" ? { text: entry, klass: "" } : entry))
        : [{ text: "Welcome back, wizard.", klass: "" }];
    }

    function applyOfflineProgress(previousTick) {
      if (!previousTick) return;
      const elapsedSeconds = Math.min((Date.now() - previousTick) / 1000, 6 * 60 * 60);
      if (elapsedSeconds <= 2) return;
      const gained = getMps() * elapsedSeconds;
      if (gained <= 0) return;

      state.power += gained;
      state.totalPower += gained;
      state.mana += gained * 0.25;
      addLog(`You were away for ${Math.floor(elapsedSeconds)}s and gained ${format(gained)} power and ${format(gained * 0.25)} mana.`, "warn");
    }

    function loadGame() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;

      try {
        const parsed = JSON.parse(raw);
        const previousTick = Number(parsed.lastTick);
        normalizeLoadedState(parsed);
        applyOfflineProgress(previousTick);
        state.lastTick = Date.now();
        addLog("Save loaded.", "ok");
      } catch {
        addLog("Save file corrupted. Starting fresh.", "danger");
      }
    }

    function resetGame() {
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }

    function renderStructures() {
      els.structures.innerHTML = "";
      for (const [key, data] of Object.entries(structureData)) {
        const owned = state.structures[key];
        const nextCost = getStructureCost(key, 0);
        const bulkCost = getBulkStructureCost(key, state.buyAmount);
        const disabled = !canAfford(bulkCost);

        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${data.image}" alt="${data.name} icon" title="${data.tooltip}" />
          <div>
            <div class="name">${data.name} <span class="pill">Owned: ${owned}</span></div>
            <div class="meta">+${format(data.mps)}/sec each ‚Ä¢ Next: ${format(nextCost)} power</div>
            <div class="meta">Buy ${state.buyAmount}: ${format(bulkCost)} power</div>
          </div>
          <button ${disabled ? "disabled" : ""}>Buy x${state.buyAmount}</button>
        `;

        const buyButton = card.querySelector("button");
        buyButton.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          buyStructure(key);
        });
        els.structures.appendChild(card);
      }
    }

    function renderUpgrades() {
      const visibleEntries = [];
      for (const [key, up] of Object.entries(upgradeData)) {
        const level = upgradeLevel(key);
        const nextCost = getUpgradeCost(key);
        const requirementMet = meetsUpgradeRequirement(key);
        const canReveal = Number.isFinite(nextCost) && state.power >= nextCost * 0.5;
        if (level > 0 || !requirementMet || !canReveal) continue;
        visibleEntries.push({ key, up, nextCost, requirementMet });
      }

      const renderKey = JSON.stringify(visibleEntries.map((entry) => {
        const affordable = canAfford(entry.nextCost);
        return [entry.key, affordable ? 1 : 0];
      }));
      if (renderKey === previousUpgradeRenderKey) return;
      previousUpgradeRenderKey = renderKey;

      els.upgrades.innerHTML = "";
      for (const { key, up, nextCost, requirementMet } of visibleEntries) {
        const disabled = !requirementMet || !canAfford(nextCost);
        const card = document.createElement("div");
        card.className = `upgrade-icon${disabled ? " disabled" : ""}`;
        card.tabIndex = 0;
        card.setAttribute("role", "button");
        card.setAttribute("aria-label", `Buy upgrade ${up.name}`);
        card.innerHTML = `
          <img class="item-icon" src="${up.image}" alt="${up.name} icon" />
          <div class="upgrade-tooltip">
            <b>${up.name}</b>
            <div>${up.effect}</div>
            <div>Cost: ${Number.isFinite(nextCost) ? format(nextCost) : "--"} power</div>
            ${up.requirementText ? `<div>Req: ${up.requirementText}${requirementMet ? "" : " (not met)"}</div>` : ""}
            <div>${up.tooltip}</div>
          </div>
        `;

        card.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (disabled) return;
          buyUpgrade(key);
        });

        card.addEventListener("keydown", (event) => {
          if (event.key !== "Enter" && event.key !== " ") return;
          event.preventDefault();
          if (disabled) return;
          buyUpgrade(key);
        });

        els.upgrades.appendChild(card);
      }

      if (visibleEntries.length === 0) {
        const empty = document.createElement("div");
        empty.className = "upgrade-empty";
        empty.textContent = "Earn more power and structures to reveal your next upgrades.";
        els.upgrades.appendChild(empty);
      }
    }

    function renderQuickslots() {
      els.quickslots.innerHTML = "";
      for (let idx = 0; idx < spellQuickslotOrder.length; idx += 1) {
        const key = spellQuickslotOrder[idx];
        const spell = spellData[key];
        if (!spell) continue;
        const unlocked = isSpellUnlocked(key);
        const cost = spellCost(key);
        const canCast = unlocked && canAffordMana(cost);

        const slot = document.createElement("button");
        slot.type = "button";
        slot.className = `quickslot ${state.activeSpell === key ? "active" : ""}`;
        slot.disabled = !canCast;
        slot.innerHTML = `
          <span class="slot-key">${idx + 1}</span>
          <img src="${spell.image}" alt="${spell.name} icon" />
          <span>${spell.name}</span>
          <span class="slot-cost">${unlocked ? format(cost) + " mana" : "Locked"}</span>
        `;
        slot.title = unlocked ? `Cast ${spell.name}` : `Unlock at ${format(spell.unlockAt)} total power`;
        slot.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          castSpell(key);
        });
        els.quickslots.appendChild(slot);
      }
    }

    function renderAchievements() {
      els.achievements.innerHTML = "";
      for (const achievement of achievementData) {
        const unlocked = state.achievements[achievement.key];
        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${achievement.image}" alt="${achievement.name} icon" title="${achievement.tooltip}" />
          <div>
            <div class="name">${achievement.name} ${unlocked ? '<span class="pill">Unlocked</span>' : ""}</div>
            <div class="meta">How to unlock: ${achievement.requirement}</div>
            <div class="meta">Reward: ${achievement.reward}</div>
          </div>
          <button disabled>${unlocked ? "Unlocked" : "Locked"}</button>
        `;
        els.achievements.appendChild(card);
      }
    }

    function renderLog() {
      els.log.innerHTML = state.log
        .map((entry) => `<div class="${entry.klass || ""}">${entry.text}</div>`)
        .join("");
    }

    function render() {
      const mps = getMps();
      els.power.textContent = format(state.power);
      els.totalPower.textContent = format(state.totalPower);
      els.mps.textContent = format(mps);
      els.rank.textContent = rankFromPower(state.totalPower);
      const activeSpell = spellData[state.activeSpell] || spellData.bolt;
      els.powerMirror.textContent = format(state.power);
      els.manaMirror.textContent = format(state.mana);
            els.activeSpellName.textContent = activeSpell.name;
      els.spellPower.textContent = `+${format(spellPower(state.activeSpell))} power`;

      for (const btn of els.buyToggle.querySelectorAll("button")) {
        btn.classList.toggle("active", Number(btn.dataset.buy) === state.buyAmount);
      }

      renderStructures();
      renderUpgrades();
      renderQuickslots();
      renderAchievements();
      renderLog();
    }

    function gameLoop() {
      const now = Date.now();
      const delta = Math.min((now - state.lastTick) / 1000, 1);
      state.lastTick = now;
      const gain = getMps() * delta;
      if (gain > 0) {
        state.power += gain;
        state.totalPower += gain;
        state.mana += gain * 0.25;
      }

      autoUnlockAchievements();
      render();
    }

    els.castBtn.addEventListener("click", castSpell);
    els.saveBtn.addEventListener("click", () => saveGame(true));
    els.resetBtn.addEventListener("click", () => {
      if (confirm("Reset all progress?")) resetGame();
    });
    els.buyToggle.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLButtonElement)) return;
      const amount = Number(target.dataset.buy);
      if (![1, 10, 25].includes(amount)) return;
      state.buyAmount = amount;
      render();
    });

    window.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        event.preventDefault();
        castSpell();
        return;
      }

      if (event.code.startsWith("Digit")) {
        const slotNumber = Number(event.code.slice(5));
        if (slotNumber >= 1 && slotNumber <= spellQuickslotOrder.length) {
          event.preventDefault();
          castSpell(spellQuickslotOrder[slotNumber - 1]);
        }
      }
    });

    loadGame();
    render();
    setInterval(gameLoop, 100);
    setInterval(() => saveGame(false), AUTO_SAVE_MS);
  </script>
  </body>
</html>
