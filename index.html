<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arcane Idle: Wizard Tower</title>
  <style>
    :root {
      color-scheme: dark;
      --accent: #9f43ff;
      --accent-2: #1fb9ff;
      --gold: #ffcb67;
      --ember: #ff7e36;
      --text: #f7edcf;
      --muted: #c4b58f;
      --ok: #84efbb;
      --warn: #ffd479;
      --danger: #ff7f9e;
      --frame: #3e2a17;
      --frame-edge: #8a6533;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Trebuchet MS", "Segoe UI", system-ui, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 50% 15%, rgba(59, 85, 147, 0.55) 0%, transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(106, 51, 153, 0.4) 0%, transparent 28%),
        radial-gradient(circle at 15% 85%, rgba(163, 87, 28, 0.26) 0%, transparent 28%),
        linear-gradient(180deg, #17131d 0%, #0c0a10 100%);
      padding: 20px;
      letter-spacing: 0.02em;
    }

    .game {
      max-width: 1180px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 18px;
    }

    .panel {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.24)),
        radial-gradient(circle at 30% 0%, rgba(143, 84, 37, 0.25), transparent 35%),
        linear-gradient(180deg, #31241b, #24180f);
      border: 2px solid var(--frame-edge);
      border-radius: 12px;
      padding: 16px;
      backdrop-filter: blur(3px);
      box-shadow:
        inset 0 0 0 2px rgba(19, 12, 7, 0.7),
        0 12px 28px rgba(0, 0, 0, 0.45);
    }

    .wide { grid-column: 1 / -1; }

    h1, h2, h3 {
      margin: 0 0 10px;
      font-family: Georgia, "Times New Roman", serif;
      letter-spacing: 0.04em;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
    }

    h1 {
      font-size: 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .sub {
      color: var(--muted);
      font-size: 1rem;
      margin-bottom: 10px;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .level-panel {
      margin-top: 12px;
      background: linear-gradient(180deg, rgba(16, 12, 8, 0.9), rgba(33, 23, 15, 0.8));
      border: 1px solid rgba(255, 196, 97, 0.4);
      border-radius: 10px;
      padding: 10px;
    }

    .level-panel-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--muted);
      font-size: 0.82rem;
      margin-bottom: 8px;
    }

    .level-bar {
      height: 12px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(148, 203, 255, 0.35);
    }

    .level-bar > span {
      display: block;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #1fb9ff, #9f43ff);
      box-shadow: 0 0 10px rgba(122, 162, 255, 0.55);
      transition: width 0.2s ease;
    }

    .stat {
      background: linear-gradient(180deg, rgba(22, 18, 12, 0.8), rgba(16, 12, 8, 0.94));
      border-radius: 10px;
      padding: 10px;
      border: 1px solid rgba(204, 147, 72, 0.42);
      box-shadow: inset 0 1px 0 rgba(255, 214, 135, 0.2);
    }

    .label { color: var(--muted); font-size: 0.82rem; }
    .value { font-size: 1.2rem; font-weight: 700; }

    button {
      width: 100%;
      border: 1px solid rgba(255, 204, 122, 0.65);
      border-radius: 10px;
      padding: 10px 12px;
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #7428d1, #43137f);
      color: white;
      cursor: pointer;
      font-weight: 700;
      transition: transform 0.08s ease, filter 0.15s ease;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.24),
        0 2px 8px rgba(0, 0, 0, 0.42);
      text-transform: uppercase;
    }

    button:hover:not(:disabled) { filter: brightness(1.08); }
    button:active:not(:disabled) { transform: scale(0.985); }
    button:disabled { cursor: not-allowed; opacity: 0.45; }

    .btn-secondary {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #215389, #15325f);
    }

    .btn-danger {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.12), transparent 40%),
        linear-gradient(135deg, #b6492e, #7f2214);
    }

    .btn-ghost {
      width: auto;
      padding: 7px 10px;
      font-size: 0.72rem;
      background: rgba(12, 8, 4, 0.22);
      border: 1px solid rgba(255, 204, 122, 0.55);
      backdrop-filter: blur(1.5px);
    }

    .btn-ghost:disabled {
      opacity: 1;
      filter: saturate(0.6);
    }

    .shop {
      display: grid;
      gap: 10px;
      margin-top: 8px;
    }

    .upgrade-grid {
      grid-template-columns: repeat(auto-fill, minmax(86px, 1fr));
      gap: 12px;
      align-items: start;
    }

    .upgrade-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .upgrade-head h2 {
      margin: 0;
    }

    .item {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 10px;
      align-items: center;
      background: linear-gradient(180deg, rgba(18, 13, 9, 0.9), rgba(43, 28, 16, 0.75));
      border-radius: 10px;
      border: 1px solid rgba(255, 196, 97, 0.28);
      padding: 10px;
    }

    .item-icon {
      width: 64px;
      height: 64px;
      border-radius: 10px;
      border: 1px solid rgba(255, 216, 147, 0.38);
      object-fit: cover;
      background: rgba(0, 0, 0, 0.35);
      box-shadow: 0 0 12px rgba(143, 67, 255, 0.4);
    }

    .upgrade-icon {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 12px;
      border: 1px solid rgba(255, 196, 97, 0.4);
      background: linear-gradient(180deg, rgba(18, 13, 9, 0.95), rgba(43, 28, 16, 0.8));
      padding: 8px;
      min-height: 86px;
      cursor: pointer;
      transition: transform 0.12s ease, border-color 0.12s ease;
    }

    .upgrade-icon:hover,
    .upgrade-icon:focus-visible {
      transform: translateY(-1px);
      border-color: rgba(255, 216, 147, 0.9);
      outline: none;
    }

    .upgrade-icon.disabled {
      cursor: not-allowed;
      opacity: 0.58;
      background: linear-gradient(180deg, rgba(16, 11, 7, 0.75), rgba(25, 16, 10, 0.6));
    }

    .upgrade-icon .item-icon {
      width: 56px;
      height: 56px;
      margin: 0;
    }

    .upgrade-tooltip {
      position: absolute;
      left: 50%;
      bottom: calc(100% + 12px);
      transform: translateX(-50%) translateY(0);
      width: min(320px, 78vw);
      padding: 12px 13px;
      border-radius: 10px;
      border: 1px solid rgba(255, 216, 147, 0.55);
      background: rgba(11, 8, 6, 0.97);
      color: #ffe7bf;
      font-size: 0.92rem;
      line-height: 1.35;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      z-index: 12;
      text-align: left;
    }

    .upgrade-tooltip b {
      display: block;
      margin-bottom: 6px;
      color: #fff6e0;
      font-size: 0.98rem;
    }

    .upgrade-icon:hover .upgrade-tooltip,
    .upgrade-icon:focus-visible .upgrade-tooltip,
    .upgrade-icon:focus-within .upgrade-tooltip {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .upgrade-empty {
      color: var(--muted);
      padding: 10px;
      border-radius: 10px;
      border: 1px dashed rgba(255, 196, 97, 0.35);
      background: rgba(0, 0, 0, 0.2);
      text-align: center;
      font-size: 0.9rem;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(6, 4, 3, 0.78);
      display: grid;
      place-items: center;
      z-index: 1100;
      padding: 20px;
    }

    .modal-overlay.hidden {
      display: none;
    }

    .upgrade-modal {
      width: min(860px, 96vw);
      max-height: 82vh;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      padding: 14px;
      border-radius: 12px;
      border: 1px solid rgba(255, 196, 97, 0.5);
      background: linear-gradient(180deg, rgba(38, 22, 12, 0.98), rgba(15, 10, 6, 0.96));
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.55);
    }

    .upgrade-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .upgrade-modal-header h3 {
      margin: 0;
    }

    .upgrade-modal-list {
      overflow: auto;
      display: grid;
      gap: 8px;
      padding-right: 4px;
    }

    .upgrade-modal-item {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 10px;
      align-items: start;
      padding: 9px;
      border-radius: 10px;
      border: 1px solid rgba(255, 196, 97, 0.28);
      background: rgba(0, 0, 0, 0.22);
    }

    .upgrade-modal-item .meta {
      margin-top: 4px;
    }

    .name { font-weight: 700; }
    .meta { color: var(--muted); font-size: 0.85rem; margin-top: 2px; }

    .pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(34, 110, 171, 0.4), rgba(26, 69, 112, 0.8));
      color: #9fddff;
      font-size: 0.8rem;
      margin-left: 4px;
      border: 1px solid rgba(159, 221, 255, 0.35);
    }

    .row { display: flex; gap: 10px; }
    .row button { flex: 1; }

    .buy-toggle {
      display: flex;
      border: 1px solid rgba(255, 202, 125, 0.5);
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
      background: rgba(0, 0, 0, 0.3);
    }

    .buy-toggle button {
      border-radius: 0;
      min-width: 58px;
      background: rgba(23, 14, 9, 0.85);
      font-weight: 600;
    }

    .buy-toggle .active {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #8f2adb, #57149d);
    }

    #log {
      height: 170px;
      overflow: auto;
      font-size: 0.9rem;
      background: rgba(8, 8, 8, 0.55);
      border-radius: 10px;
      padding: 8px;
      border: 1px solid rgba(255, 192, 106, 0.33);
      margin-top: 10px;
    }

    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
    .danger { color: var(--danger); }

    .tiny { font-size: 0.8rem; color: var(--muted); margin-top: 10px; }

    .resource-strips {
      margin-top: 12px;
      display: grid;
      gap: 8px;
    }

    .resource {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 233, 181, 0.35);
      background: linear-gradient(135deg, rgba(36, 22, 12, 0.95), rgba(59, 37, 21, 0.75));
      font-weight: 700;
    }

    .resource b {
      color: var(--gold);
    }

    .resource-inline {
      justify-content: space-between;
      gap: 12px;
      flex-wrap: nowrap;
    }

    .resource-inline span {
      display: inline-flex;
      gap: 6px;
      align-items: baseline;
      white-space: nowrap;
    }

    .achievement-popups {
      position: fixed;
      right: 20px;
      bottom: 20px;
      display: grid;
      gap: 8px;
      z-index: 999;
      pointer-events: none;
    }

    .achievement-popup {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 220px;
      max-width: 300px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 196, 97, 0.4);
      background: linear-gradient(180deg, rgba(34, 19, 10, 0.95), rgba(14, 9, 5, 0.95));
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transform: translateY(6px);
      animation: popup-in 0.25s ease forwards;
    }

    .achievement-popup img {
      width: 34px;
      height: 34px;
      border-radius: 7px;
      border: 1px solid rgba(255, 216, 147, 0.4);
    }

    @keyframes popup-in {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }


    .spell-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .quickslot-bar {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(92px, 1fr));
      gap: 8px;
    }

    .quickslot {
      border: 1px solid rgba(255, 202, 125, 0.52);
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(36, 18, 41, 0.92), rgba(13, 10, 20, 0.95));
      color: var(--text);
      padding: 6px;
      display: grid;
      gap: 4px;
      align-items: center;
      justify-items: center;
      min-height: 74px;
    }

    .quickslot .slot-key {
      font-size: 0.72rem;
      color: var(--muted);
    }

    .quickslot img {
      width: 30px;
      height: 30px;
      border-radius: 7px;
      border: 1px solid rgba(186, 225, 255, 0.55);
      background: rgba(0, 0, 0, 0.35);
    }

    .quickslot .slot-cost {
      font-size: 0.72rem;
      color: var(--muted);
    }

    .quickslot.active {
      box-shadow: 0 0 0 2px rgba(159, 67, 255, 0.65) inset;
    }

    .td-grid {
      display: grid;
      grid-template-columns: 1.3fr 1fr;
      gap: 10px;
      align-items: stretch;
      margin-top: 10px;
    }

    .td-lane {
      border: 1px solid rgba(115, 196, 255, 0.32);
      border-radius: 10px;
      padding: 10px;
      background: linear-gradient(180deg, rgba(19, 13, 23, 0.9), rgba(8, 9, 18, 0.95));
    }

    .td-track {
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 196, 97, 0.24);
      background: rgba(0, 0, 0, 0.5);
      overflow: hidden;
      margin: 8px 0;
    }

    .td-battlefield {
      position: relative;
      height: 86px;
      border-radius: 10px;
      margin: 10px 0 8px;
      border: 1px solid rgba(115, 196, 255, 0.32);
      background: linear-gradient(180deg, rgba(9, 18, 32, 0.95), rgba(10, 9, 16, 0.95));
      overflow: hidden;
    }

    .td-wave-fill {
      position: absolute;
      inset: 0;
      width: 0;
      background: linear-gradient(90deg, rgba(54, 165, 245, 0.42), rgba(159, 67, 255, 0.35));
      transition: width 0.12s linear;
    }

    .td-wave-fill.low-power {
      background: linear-gradient(90deg, rgba(255, 105, 77, 0.48), rgba(255, 186, 92, 0.35));
    }

    .td-tower-icon,
    .td-enemy-icon {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.8rem;
      filter: drop-shadow(0 0 7px rgba(0, 0, 0, 0.55));
      z-index: 2;
    }

    .td-tower-icon { right: 8px; }
    .td-enemy-icon { left: 8px; transition: left 0.12s linear; }

    .td-power-warning {
      font-size: 0.75rem;
      color: #ffbf9e;
      margin-top: 4px;
      min-height: 1.1em;
    }

    .td-progress {
      display: block;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #3bb3ff, #9f43ff);
      transition: width 0.12s linear;
    }

    .td-enemy {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .td-stats {
      display: grid;
      gap: 8px;
    }

    .td-stat {
      border: 1px solid rgba(255, 196, 97, 0.22);
      border-radius: 10px;
      padding: 8px;
      background: rgba(11, 9, 16, 0.65);
    }

    .td-stat b {
      display: block;
      margin-top: 2px;
    }

    .equipment-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .gear-slot {
      border: 1px solid rgba(255, 202, 125, 0.5);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(28, 17, 10, 0.95), rgba(12, 9, 8, 0.95));
      color: var(--text);
      padding: 10px;
      display: grid;
      gap: 4px;
      text-align: left;
      min-height: 98px;
      align-content: start;
    }

    .gear-slot.empty {
      border-style: dashed;
      border-color: rgba(255, 202, 125, 0.35);
      color: var(--muted);
    }

    .gear-slot .slot-type {
      font-size: 0.75rem;
      text-transform: uppercase;
      color: var(--muted);
    }

    .gear-slot .slot-item {
      font-size: 0.95rem;
      font-weight: 700;
    }

    .gear-slot .slot-equipped {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .gear-slot .slot-equipped img {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      border: 1px solid rgba(186, 225, 255, 0.55);
      background: rgba(0, 0, 0, 0.3);
    }

    .gear-slot .slot-profit {
      font-size: 0.78rem;
      color: #9fddff;
    }

    .spell-card {
      display: grid;
      gap: 8px;
      background: linear-gradient(180deg, rgba(16, 10, 6, 0.95), rgba(42, 22, 44, 0.7));
      border: 1px solid rgba(170, 127, 255, 0.48);
      border-radius: 12px;
      padding: 10px;
    }

    .spell-head {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .spell-icon {
      width: 58px;
      height: 58px;
      border-radius: 12px;
      border: 1px solid rgba(186, 225, 255, 0.55);
      box-shadow: 0 0 12px rgba(79, 174, 255, 0.45);
      background: rgba(0,0,0,0.35);
    }

    .spell-mini {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .scroll-shop {
      max-height: 320px;
      overflow: auto;
      padding-right: 4px;
      border: 1px solid rgba(255, 192, 106, 0.25);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.18);
    }

    .upgrade-grid.scroll-shop {
      max-height: none;
      overflow: visible;
    }

    .pet-slot-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    @media (max-width: 900px) {
      .game { grid-template-columns: 1fr; }
      .stats { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .equipment-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .td-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="game">
    <section class="panel wide">
      <h1>
        <span>üßô Arcane Idle: Wizard Tower</span>
        <span class="pill">Idle + Clicker</span>
      </h1>
      <div class="sub">Gather power, train apprentices, and automate your magical empire with a richer fantasy HUD.</div>
      <div class="row">
        <button id="clickBtn">üñ±Ô∏è Gather Power <span id="clickGain">(+1)</span></button>
        <button id="saveBtn" class="btn-secondary">üíæ Save</button>
        <button id="resetBtn" class="btn-danger">‚ôªÔ∏è Reset</button>
      </div>
      <div class="stats">
        <div class="stat"><div class="label">Arcane Rank</div><div class="value" id="rank">Novice</div></div>
      </div>
      <div class="level-panel">
        <div class="level-panel-head">
          <span id="playerLevel">Level 1</span>
          <span id="levelProfitBonus">+0% profit</span>
        </div>
        <div class="level-bar"><span id="levelProgressFill"></span></div>
        <div class="tiny" id="levelProgressText">0 / 0 power to next level</div>
      </div>
      <div class="resource-strips">
        <div class="resource resource-inline">
          <span>‚ö° Power Reserve <b id="power">0</b></span>
          <span>üìà Power / sec <b id="mps">0</b></span>
          <span>‚ú® Total Power Ever <b id="totalPower">0</b></span>
        </div>
        <div class="resource"><span>üî∑ Spell Mana</span><b id="manaMirror">0</b></div>
      </div>
      <div class="tiny">Tip: Click a quickslot to assign a learned spell. Press <strong>1-5</strong> to cast from a specific slot. <strong>Space</strong> still casts the selected slot.</div>
      <div class="tiny">Selected: <strong id="activeSpellName">Arcane Spell 1</strong> ‚Ä¢ Effect: <span id="spellPower">+0 power/sec</span> ‚Ä¢ Time: <span id="spellTime">ready</span></div>
    </section>


    <section class="panel wide">
      <h2>üèπ Arcane Tower Defense</h2>
      <div class="meta">Your idle wizard total power scales your tower damage. Casting spells empowers the lane with burst damage and shorter enemy freezes.</div>
      <div class="td-grid">
        <div class="td-lane">
          <div class="tiny">Wave <b id="tdWave">1</b> ‚Ä¢ Breaches <b id="tdBreaches">0</b> / 5</div>
          <div class="td-battlefield">
            <span id="tdWaveFill" class="td-wave-fill"></span>
            <span id="tdEnemyIcon" class="td-enemy-icon">üåä</span>
            <span class="td-tower-icon">üè∞</span>
          </div>
          <div class="td-track"><span id="tdProgress" class="td-progress"></span></div>
          <div class="tiny">Enemy HP</div>
          <div class="td-track"><span id="tdEnemyHp" class="td-progress"></span></div>
          <div id="tdPowerWarning" class="td-power-warning"></div>
          <div id="tdEnemyInfo" class="td-enemy">A scouting wisp approaches...</div>
        </div>
        <div class="td-stats">
          <div class="td-stat"><span class="label">Tower DPS (Idle Wizard scaled)</span><b id="tdDps">0</b></div>
          <div class="td-stat"><span class="label">Spell Pressure Bonus</span><b id="tdSpellBonus">x1.00</b></div>
          <div class="td-stat"><span class="label">Current Reward</span><b id="tdReward">0 power / 0 mana</b></div>
        </div>
      </div>
    </section>

    <section class="panel wide">
      <h2>‚öîÔ∏è Spell Quickslots</h2>
      <div id="quickslots" class="quickslot-bar"></div>
    </section>

    <section class="panel">
      <div class="upgrade-head">
        <h2>üîÆ Upgrades</h2>
        <button id="showAllUpgradesBtn" class="btn-ghost" type="button">All Upgrades</button>
      </div>
      <div id="upgrades" class="shop scroll-shop upgrade-grid"></div>
    </section>

    <section class="panel">
      <h2>üß™ Structures</h2>
      <div class="buy-toggle" id="buyToggle">
        <button data-buy="1" class="active">x1</button>
        <button data-buy="10">x10</button>
        <button data-buy="25">x25</button>
      </div>
      <div id="structures" class="shop scroll-shop"></div>
    </section>

    <section class="panel">
      <h2>üõ°Ô∏è Equipment</h2>
      <div class="meta">Equip gear to boost structure profits. Click a slot to browse and buy items with power.</div>
      <div id="equipmentBonus" class="meta"></div>
      <label class="tiny"><input type="checkbox" id="equipmentLevelingToggle" /> Enable equipment leveling (exponential power costs)</label>
      <div id="equipmentSlots" class="equipment-grid"></div>
    </section>

    <section class="panel">
      <h2>üêæ Pets</h2>
      <div class="meta">Persistent support units that level through use and grant passive scaling bonuses.</div>
      <div class="pet-slot-head">
        <div id="petSlotsInfo" class="meta"></div>
      </div>
      <div id="pets" class="shop scroll-shop"></div>
    </section>


    <section class="panel">
      <h2>üèÜ Achievements</h2>
      <div id="achievements" class="shop scroll-shop"></div>
    </section>

    <section class="panel wide">
      <h2>üìú Event Log</h2>
      <div id="log"></div>
    </section>
  </main>

  <div id="upgradeListModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="upgradeListTitle">
    <div class="upgrade-modal panel">
      <div class="upgrade-modal-header">
        <h3 id="upgradeListTitle">All Upgrades & Unlock Conditions</h3>
        <button id="closeUpgradeListBtn" class="btn-ghost" type="button">Close</button>
      </div>
      <div id="upgradeListBody" class="upgrade-modal-list"></div>
    </div>
  </div>

  <div id="gearModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="gearModalTitle">
    <div class="upgrade-modal panel">
      <div class="upgrade-modal-header">
        <h3 id="gearModalTitle">Slot Gear</h3>
        <button id="closeGearModalBtn" class="btn-ghost" type="button">Close</button>
      </div>
      <div id="gearModalBody" class="upgrade-modal-list"></div>
    </div>
  </div>

  <div id="spellSlotModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="spellSlotModalTitle">
    <div class="upgrade-modal panel">
      <div class="upgrade-modal-header">
        <h3 id="spellSlotModalTitle">Assign Spell</h3>
        <button id="closeSpellSlotModalBtn" class="btn-ghost" type="button">Close</button>
      </div>
      <div id="spellSlotModalBody" class="upgrade-modal-list"></div>
    </div>
  </div>

  <div id="achievementPopups" class="achievement-popups" aria-live="polite"></div>

  <script>
    const STORAGE_KEY = "arcane-idle-save-v2";
    const AUTO_SAVE_MS = 20000;


    function webIcon(glyph) {
      const codepoint = Array.from(glyph)
        .map((char) => char.codePointAt(0).toString(16))
        .filter((code) => code !== "fe0f")
        .join("-");
      return `https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/72x72/${codepoint}.png`;
    }

    const structureData = {
      apprentice: { name: "Apprentice", baseCost: 15, mps: 0.6, growth: 1.15, image: webIcon("üßô"), tooltip: "Apprentices channel basic mana streams and are your first source of passive mana income." },
      crystal: { name: "Mana Crystal", baseCost: 100, mps: 4, growth: 1.16, image: webIcon("üî∑"), tooltip: "Mana Crystals store ambient arcane power to sharply increase mana per second." },
      library: { name: "Enchanted Library", baseCost: 550, mps: 22, growth: 1.18, image: webIcon("üìö"), tooltip: "Enchanted Libraries unlock efficient spellcraft methods that multiply your idle gains." },
      golem: { name: "Arcane Golem", baseCost: 2600, mps: 95, growth: 1.2, image: webIcon("üóø"), tooltip: "Arcane Golems automate heavy magical labor and massively boost production." },
      observatory: { name: "Astral Observatory", baseCost: 11000, mps: 440, growth: 1.23, image: webIcon("üî≠"), tooltip: "Astral Observatories align your tower with leylines for elite mana generation." },
      manaForge: { name: "Mana Forge", baseCost: 42000, mps: 1650, growth: 1.24, image: webIcon("üî•"), tooltip: "A blazing forge that condenses raw arcana into high-output power cores." },
      portalNexus: { name: "Portal Nexus", baseCost: 140000, mps: 5200, growth: 1.26, image: webIcon("üåÄ"), tooltip: "Portal arrays siphon mana from nearby dimensions." },
      skyCitadel: { name: "Sky Citadel", baseCost: 420000, mps: 18000, growth: 1.27, image: webIcon("üè∞"), tooltip: "Floating mage-citadels create massive autonomous arcane output." },
      voidReactor: { name: "Void Reactor", baseCost: 1300000, mps: 63000, growth: 1.29, image: webIcon("üåå"), tooltip: "Harnesses dark-space turbulence for late-game production spikes." },
    };

    const upgradeData = {
      focusedWand: {
        name: "Focused Wand",
        cost: 60,
        effect: "Double Arcane Bolt power",
        school: "Arcane",
        image: webIcon("ü™Ñ"),
        tooltip: "Focused Wand strengthens each manual cast, making every click worth twice as much mana.",
        apply: (state) => state.clickPower *= 2,
      },
      dualChanneling: {
        name: "Dual Channeling",
        cost: 450,
        effect: "Arcane Bolt gains +8 power",
        school: "Arcane",
        image: webIcon("‚ú®"),
        tooltip: "Dual Channeling weaves two spells at once so each cast adds a large flat mana bonus.",
        apply: (state) => state.clickPower += 8,
      },
      runeEtching: {
        name: "Rune Etching",
        cost: 1200,
        effect: "All spell power +30%",
        school: "Arcane",
        image: webIcon("üîØ"),
        tooltip: "Arcane runes amplify the impact of every offensive cast.",
        apply: () => {},
      },
      manaCompression: {
        name: "Mana Compression",
        cost: 4200,
        effect: "Spell costs -20%",
        school: "Arcane",
        image: webIcon("üßø"),
        tooltip: "Dense mana channels reduce the mana needed to cast heavy spells.",
        apply: () => {},
      },
      leylineBinding: {
        name: "Leyline Binding",
        cost: 1400,
        effect: "All structures produce +25% mana",
        school: "Nature",
        image: webIcon("üß¨"),
        tooltip: "Leyline Binding anchors your tower to nearby leylines, increasing all structure output.",
        apply: () => {},
      },
      crystallizedThought: {
        name: "Crystallized Thought",
        cost: 6000,
        effect: "All structures produce +50% mana",
        school: "Mind",
        image: webIcon("üíé"),
        tooltip: "Crystallized Thought refines magical focus, delivering a major global boost to structures.",
        apply: () => {},
      },
      archmageSigil: {
        name: "Archmage Sigil",
        cost: 26000,
        effect: "All structures produce +120% mana",
        school: "Arcane",
        image: webIcon("üî±"),
        tooltip: "An ancient sigil that supercharges every mana engine in your empire.",
        apply: () => {},
      },
      tempestMastery: {
        name: "Tempest Mastery",
        cost: 90000,
        effect: "Lightning and Meteor spells +90% power",
        school: "Elemental",
        image: webIcon("‚ö°"),
        tooltip: "Mastery over storm magic dramatically boosts high-tier burst spells.",
        apply: () => {},
      },
      planarRefinery: {
        name: "Planar Refinery",
        cost: 350000,
        effect: "All structures produce +180% mana",
        school: "Void",
        image: webIcon("üè≠"),
        tooltip: "Distills planar residue into endless fuel for your late-game production chain.",
        apply: () => {},
      },
      celestialLattice: {
        name: "Celestial Lattice",
        cost: 1200000,
        effect: "All spell power +120%",
        school: "Celestial",
        image: webIcon("üå†"),
        tooltip: "Interlocks starlight and sigils so every spell detonates with vastly greater force.",
        apply: () => {},
      },
      singularityCore: {
        name: "Singularity Core",
        cost: 4500000,
        effect: "All structures produce +300% mana and spell costs -25%",
        school: "Void",
        image: webIcon("üï≥Ô∏è"),
        tooltip: "A compressed void-kernel that warps production and dramatically improves spell efficiency.",
        apply: () => {},
      },
      apprenticeTheory: {
        name: "Apprentice Theory",
        cost: 900,
        effect: "Unlocks scaling Arcane Study research",
        school: "Arcane",
        image: webIcon("üìú"),
        tooltip: "Inspired by Idle Wizard's layered upgrade trees: this opens repeatable spell research.",
        requirementText: "Reach 1,500 total power",
        requirement: (s) => s.totalPower >= 1500,
        apply: () => {},
      },
      arcaneStudy: {
        name: "Arcane Study",
        cost: 1500,
        effect: "+8% spell power per level",
        school: "Arcane",
        repeatable: true,
        growth: 1.7,
        image: webIcon("üìò"),
        tooltip: "A repeatable tome upgrade inspired by Idle Wizard's scaling upgrade purchases.",
        requirementText: "Learn Apprentice Theory",
        requirement: (s) => s.upgrades.apprenticeTheory,
        apply: () => {},
      },
      manaInfusion: {
        name: "Mana Infusion",
        cost: 4000,
        effect: "+6% structure output per level",
        school: "Elemental",
        repeatable: true,
        growth: 1.8,
        image: webIcon("üí†"),
        tooltip: "A scaling infusion line similar to long-form Idle Wizard enhancement chains.",
        requirementText: "Own 12 total structures",
        requirement: (s) => Object.values(s.structures).reduce((sum, amount) => sum + amount, 0) >= 12,
        apply: () => {},
      },
      ritualEconomy: {
        name: "Ritual Economy",
        cost: 9000,
        effect: "Spell costs -3% per level (cap 45%)",
        school: "Void",
        repeatable: true,
        growth: 2,
        image: webIcon("üïØÔ∏è"),
        tooltip: "Late-game spell efficiency research modeled after compounding upgrade systems.",
        requirementText: "Cast 80 spells",
        requirement: (s) => s.spellCasts >= 80,
        apply: () => {},
      },
    };

    const structureOrder = Object.keys(structureData);
    const structureUpgradeTiers = 5;
    for (const [index, structureKey] of structureOrder.entries()) {
      const structure = structureData[structureKey];
      const structureSlug = structure.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
      for (let tier = 1; tier <= structureUpgradeTiers; tier += 1) {
        const id = `${structureSlug}-amplifier-${tier}`;
        const unlockCount = (tier * 4) + (index * 2);
        const logarithmicScale = 1 + Math.log10(structure.baseCost * (tier + 2));
        const tierScale = Math.pow(tier + 1, 1.55);
        const cost = Math.floor(structure.baseCost * 18 * logarithmicScale * tierScale);
        const bonus = Number((0.12 + (Math.log2(tier + 1) * 0.11)).toFixed(3));

        upgradeData[id] = {
          name: `${structure.name} Amplifier ${tier}`,
          cost,
          effect: `${structure.name} output +${Math.round(bonus * 100)}%`,
          school: "Structure",
          image: structure.image,
          tooltip: `Logarithmic scaling enhancement focused on ${structure.name}. Boosts only this structure for targeted growth.`,
          requirementText: `Own ${unlockCount} ${structure.name}${unlockCount === 1 ? "" : "s"}`,
          requirement: (s) => s.structures[structureKey] >= unlockCount,
          structureTarget: structureKey,
          structureBonus: bonus,
          apply: () => {},
        };
      }
    }

    const spellGlyphs = ["‚ú®", "üî•", "‚ö°", "üå†", "üåÄ", "‚ùÑÔ∏è", "üå™Ô∏è", "‚òÑÔ∏è", "üåô", "üí•", "üí´", "ü™Ñ", "üåå", "üîÆ", "üßø", "üåã", "ü™Ω", "üïØÔ∏è", "ü™ê", "üåà", "üß¨", "üíé", "‚≠ê", "‚òÄÔ∏è", "üåä", "üå±", "‚è≥", "üõ∏", "ü™û", "‚öîÔ∏è", "üß≤", "üß†", "üéá", "üåÄ", "üå´Ô∏è", "üóùÔ∏è", "üßä", "üß®", "ü¶â", "ü¶¥", "ü™¨", "üßµ", "üï≥Ô∏è", "üóø", "üõ∞Ô∏è", "üï∏Ô∏è", "ü•Ä", "üåç", "üåã", "‚òØÔ∏è"];

    const spellData = Object.fromEntries(Array.from({ length: 50 }, (_, idx) => {
      const id = `spell${idx + 1}`;
      const tier = idx + 1;
      return [id, {
        id,
        name: `Arcane Spell ${tier}`,
        basePower: Math.floor(14 * Math.pow(1.31, tier - 1)),
        manaCost: Math.max(6, Math.floor(7 * Math.pow(1.26, tier - 1))),
        durationSec: Math.max(6, 14 - Math.floor((tier - 1) / 6)),
        unlockLevel: tier === 1 ? 0 : tier + 1,
        image: webIcon(spellGlyphs[idx] || "‚ú®"),
      }];
    }));

    const spellQuickslotCount = 5;
    const tdMaxBreaches = 5;

    const petData = {
      emberFox: {
        name: "Ember Fox",
        tier: 1,
        image: webIcon("ü¶ä"),
        bonusText: "Global production",
        xpScale: 1,
        bonus: (level) => 0.08 + ((level - 1) * 0.045),
        apply: (mods, value) => { mods.production *= 1 + value; },
      },
      astralOwl: {
        name: "Astral Owl",
        tier: 1,
        image: webIcon("ü¶â"),
        bonusText: "Spell power",
        xpScale: 1,
        bonus: (level) => 0.1 + ((level - 1) * 0.06),
        apply: (mods, value) => { mods.spell *= 1 + value; },
      },
      manaSlime: {
        name: "Mana Slime",
        tier: 1,
        image: webIcon("ü´ß"),
        bonusText: "Mana from production",
        xpScale: 1.05,
        bonus: (level) => 0.12 + ((level - 1) * 0.05),
        apply: (mods, value) => { mods.manaGain *= 1 + value; },
      },
      clockworkImp: {
        name: "Clockwork Imp",
        tier: 1,
        image: webIcon("üòà"),
        bonusText: "Cast XP gain",
        xpScale: 1.12,
        bonus: (level) => 0.08 + ((level - 1) * 0.04),
        apply: (mods, value) => { mods.petXp *= 1 + value; },
      },
      voidTurtle: {
        name: "Void Turtle",
        tier: 1,
        image: webIcon("üê¢"),
        bonusText: "Offline mana",
        xpScale: 1.25,
        bonus: (level) => 0.2 + ((level - 1) * 0.07),
        apply: (mods, value) => { mods.offlineMana *= 1 + value; },
      },
      infernoFox: {
        name: "Inferno Fox",
        tier: 2,
        unlockFrom: "emberFox",
        image: webIcon("üî•"),
        bonusText: "Global production",
        xpScale: 1.38,
        bonus: (level) => 0.5 + ((level - 1) * 0.11),
        apply: (mods, value) => { mods.production *= 1 + value; },
      },
      eclipseOwl: {
        name: "Eclipse Owl",
        tier: 2,
        unlockFrom: "astralOwl",
        image: webIcon("üåí"),
        bonusText: "Spell power",
        xpScale: 1.38,
        bonus: (level) => 0.55 + ((level - 1) * 0.12),
        apply: (mods, value) => { mods.spell *= 1 + value; },
      },
      prismaticSlime: {
        name: "Prismatic Slime",
        tier: 2,
        unlockFrom: "manaSlime",
        image: webIcon("üåà"),
        bonusText: "Mana from production",
        xpScale: 1.45,
        bonus: (level) => 0.6 + ((level - 1) * 0.1),
        apply: (mods, value) => { mods.manaGain *= 1 + value; },
      },
      chronoImp: {
        name: "Chrono Imp",
        tier: 2,
        unlockFrom: "clockworkImp",
        image: webIcon("‚è±Ô∏è"),
        bonusText: "Cast XP gain",
        xpScale: 1.52,
        bonus: (level) => 0.45 + ((level - 1) * 0.09),
        apply: (mods, value) => { mods.petXp *= 1 + value; },
      },
      titanTurtle: {
        name: "Titan Turtle",
        tier: 2,
        unlockFrom: "voidTurtle",
        image: webIcon("ü™®"),
        bonusText: "Offline mana",
        xpScale: 1.6,
        bonus: (level) => 0.7 + ((level - 1) * 0.13),
        apply: (mods, value) => { mods.offlineMana *= 1 + value; },
      },
    };

    function isPetUnlocked(petKey) {
      const pet = petData[petKey];
      if (!pet) return false;
      if (!pet.unlockFrom) return true;
      return petState(pet.unlockFrom).level >= 99;
    }

    const achievementData = [
      { key: "mana1k", name: "Power Hoarder I", image: webIcon("ü•â"), test: (s) => s.totalPower >= 1000, requirement: "Accumulate 1,000 total power from any source.", reward: "+5% structure output", tooltip: "First hoarding milestone. Keep casting and buying structures until lifetime power hits 1,000." },
      { key: "mana20k", name: "Power Hoarder II", image: webIcon("ü•à"), test: (s) => s.totalPower >= 20000, requirement: "Accumulate 20,000 total power over the run.", reward: "+10% structure output", tooltip: "Advanced hoarding milestone. Scale production and idle income to reach 20,000 lifetime power." },
      { key: "mana250k", name: "Power Hoarder III", image: webIcon("ü•á"), test: (s) => s.totalPower >= 250000, requirement: "Accumulate 250,000 total power.", reward: "+15% structure output", tooltip: "A mid-game mastery checkpoint that rewards sustained scaling." },
      { key: "mana2m", name: "Power Sovereign", image: webIcon("üëë"), test: (s) => s.totalPower >= 2000000, requirement: "Accumulate 2,000,000 total power.", reward: "+25% structure output", tooltip: "A late milestone for long sessions, requiring a truly automated tower." },
      { key: "golem3", name: "Golem Battalion", image: webIcon("üèÖ"), test: (s) => s.structures.golem >= 3, requirement: "Own 3 Arcane Golems at the same time.", reward: "+15 click power", tooltip: "Construct three Arcane Golems to earn this badge and permanently strengthen manual casting." },
      { key: "towerTycoon", name: "Tower Tycoon", image: webIcon("üèõÔ∏è"), test: (s) => Object.values(s.structures).reduce((sum, amount) => sum + amount, 0) >= 80, requirement: "Own 80 total structures.", reward: "+20% structure output", tooltip: "Rewards broad investment across your whole structure roster." },
      { key: "skyLord", name: "Lord of the Sky", image: webIcon("üè∞"), test: (s) => s.structures.skyCitadel >= 5, requirement: "Own 5 Sky Citadels.", reward: "+15% spell power", tooltip: "Your floating strongholds improve spell efficiency across all casts." },
      { key: "spellweaver", name: "Spellweaver", image: webIcon("üìò"), test: (s) => s.spellCasts >= 250, requirement: "Cast 250 spells in total.", reward: "-10% spell costs", tooltip: "Dedicated casting lowers spell maintenance costs permanently." },
      { key: "voidCaller", name: "Void Caller", image: webIcon("üåå"), test: (s) => s.structures.voidReactor >= 2, requirement: "Own 2 Void Reactors.", reward: "+40 click power", tooltip: "A deep-end milestone that empowers manual burst play in the late game." },
    ];

    const gearSlotData = {
      weapon: { name: "Weapon", icon: "‚öîÔ∏è" },
      helm: { name: "Helm", icon: "ü™ñ" },
      chest: { name: "Chest", icon: "üõ°Ô∏è" },
      gloves: { name: "Gloves", icon: "üß§" },
      ring: { name: "Ring", icon: "üíç" },
      trinket: { name: "Trinket", icon: "üßø" },
    };

    function createGearSet(slotPrefix, names, icons, baseCost, baseBonus) {
      const costGrowth = 3.2;
      const bonusStep = 0.0125;
      return names.map((name, idx) => ({
        id: `${slotPrefix}-${idx + 1}`,
        name,
        icon: webIcon(icons[idx]),
        tier: idx + 1,
        cost: Math.round(baseCost * Math.pow(costGrowth, idx)),
        profitBonus: Number((baseBonus + idx * bonusStep).toFixed(3)),
      }));
    }

    const gearData = {
      weapon: createGearSet(
        "weapon",
        ["Oak Initiate Wand", "Emberglass Rod", "Stormcaller Staff", "Rift Channeler Blade", "Astral Pike of Profit", "Sunfire Scepter", "Runeforged Spear", "Tempest Halberd", "Comet Cleaver", "Nebula Scythe", "Aether Lance", "Duskfang Saber", "Moonshard Staff", "Prism Greatblade", "Starbreaker Pike", "Chrono Rapier", "Eclipse Polearm", "Voidbrand Edge", "Aurora Chakram", "Titan Arcblade", "Celestial Reaver", "Paradox Trident", "Infinity Glaive", "Mythic Arcanum Blade", "Worldspark Relicblade"],
        ["ü™Ñ", "üî•", "‚ö°", "üó°Ô∏è", "üõ°Ô∏è", "‚òÄÔ∏è", "üî±", "üå©Ô∏è", "‚òÑÔ∏è", "üåå", "üí†", "üåô", "‚ú®", "üîÆ", "‚≠ê", "‚è≥", "üåò", "üï≥Ô∏è", "üåà", "ü™ì", "üõ∞Ô∏è", "üî∫", "‚ôæÔ∏è", "üß¨", "üöÄ"],
        220,
        0.03
      ),
      helm: createGearSet(
        "helm",
        ["Linen Cowl", "Seer's Hood", "Wyrmfire Circlet", "Runic Crown", "Crown of the Archmage", "Sunveil Helm", "Tempest Visor", "Sage Diadem", "Titan Browguard", "Dawncrest Crown", "Moonlit Mask", "Aether Coronet", "Stormwake Helm", "Prismatic Tiara", "Starwrought Helm", "Chronomancer Hood", "Frosthalo Circlet", "Voidseer Crown", "Embercrest Helm", "Celestial Laurels", "Oracle Helm", "Astral Halo", "Eternity Crown", "Mythril Mindguard", "Cosmic Sovereign Helm"],
        ["üß¢", "ü™ñ", "üëë", "‚õëÔ∏è", "üéì", "‚òÄÔ∏è", "üå©Ô∏è", "üìø", "üóø", "üåÖ", "üåô", "üíé", "‚ö°", "üî∑", "‚≠ê", "‚è±Ô∏è", "‚ùÑÔ∏è", "üï≥Ô∏è", "üî•", "üå†", "üî≠", "ü™ê", "‚ôæÔ∏è", "üß†", "üåå"],
        180,
        0.025
      ),
      chest: createGearSet(
        "chest",
        ["Apprentice Robes", "Arcweave Coat", "Aetherplate Vest", "Voidbound Mail", "Mantle of Cosmos", "Sunforged Cuirass", "Tempest Jerkin", "Moonlace Armor", "Runebound Breastplate", "Comet Ward", "Astral Harness", "Starlit Bulwark", "Duskweave Tunic", "Prism Carapace", "Embermantle", "Chrono Mail", "Frostwoven Raiment", "Abyssal Vest", "Aurora Plate", "Titan Shell", "Celestial Vestments", "Oracle Carapace", "Paradox Armor", "Mythic Starcoat", "Worldheart Aegis"],
        ["üëï", "ü•ã", "ü¶∫", "üõ°Ô∏è", "üß•", "‚òÄÔ∏è", "üå©Ô∏è", "üåô", "üìú", "‚òÑÔ∏è", "üî≠", "‚≠ê", "üåí", "üî∑", "üî•", "‚è≥", "‚ùÑÔ∏è", "üï≥Ô∏è", "üåà", "ü™®", "üåå", "üîÆ", "‚ôæÔ∏è", "üß¨", "üåç"],
        250,
        0.035
      ),
      gloves: createGearSet(
        "gloves",
        ["Scribe Wraps", "Silk Grips", "Golem Gauntlets", "Fategrasps", "Starhands", "Sunthread Gloves", "Stormhide Mitts", "Moonwoven Grips", "Runebinder Gloves", "Comet Claws", "Aether Palmguards", "Dusk Talons", "Prism Knuckles", "Ember Fists", "Chrono Grips", "Frostgrasp", "Voidtouch Gloves", "Aurora Fingers", "Titan Gauntlets", "Celestial Graspers", "Oracle Touch", "Astral Handguards", "Paradox Talons", "Mythic Spellgloves", "Worldloom Mitts"],
        ["üß§", "ü™¨", "üóø", "üîÆ", "‚≠ê", "‚òÄÔ∏è", "üå©Ô∏è", "üåô", "üìú", "‚òÑÔ∏è", "üí†", "üåí", "üî∑", "üî•", "‚è±Ô∏è", "‚ùÑÔ∏è", "üï≥Ô∏è", "üåà", "ü™®", "üåå", "üëÅÔ∏è", "ü™ê", "‚ôæÔ∏è", "üß¨", "üåç"],
        130,
        0.02
      ),
      ring: createGearSet(
        "ring",
        ["Copper Band", "Moon Band", "Sigil Loop", "Nexus Ring", "Eternity Loop", "Sunband", "Tempest Ring", "Sage Coil", "Comet Loop", "Astral Ring", "Starseal Band", "Duskband", "Prism Ring", "Ember Loop", "Chrono Ring", "Frost Ring", "Void Loop", "Aurora Band", "Titan Circle", "Celestial Ring", "Oracle Loop", "Nebula Band", "Paradox Ring", "Mythic Halo Ring", "Worldthread Ring"],
        ["üíç", "üåô", "üìø", "üîÆ", "‚ôæÔ∏è", "‚òÄÔ∏è", "üå©Ô∏è", "üìò", "‚òÑÔ∏è", "ü™ê", "‚≠ê", "üåò", "üî∑", "üî•", "‚è≥", "‚ùÑÔ∏è", "üï≥Ô∏è", "üåà", "ü™®", "üåå", "üëÅÔ∏è", "üå†", "üî∫", "üß¨", "üåç"],
        90,
        0.015
      ),
      trinket: createGearSet(
        "trinket",
        ["Apprentice Charm", "Fortune Orb", "Echo Relic", "Horizon Idol", "Oracle Heart", "Sun Idol", "Tempest Totem", "Moon Relic", "Runic Fetish", "Comet Idol", "Astral Token", "Dusk Relic", "Prism Totem", "Ember Idol", "Chrono Sigil", "Frost Idol", "Void Totem", "Aurora Relic", "Titan Charm", "Celestial Idol", "Oracle Totem", "Nebula Relic", "Paradox Token", "Mythic Core", "Worldseed Charm"],
        ["üßø", "üîÆ", "üìø", "üóø", "‚ù§Ô∏è", "‚òÄÔ∏è", "üå©Ô∏è", "üåô", "üìú", "‚òÑÔ∏è", "ü™ê", "üåí", "üî∑", "üî•", "‚è±Ô∏è", "‚ùÑÔ∏è", "üï≥Ô∏è", "üåà", "ü™®", "üåå", "üëÅÔ∏è", "üå†", "‚ôæÔ∏è", "üß¨", "üåç"],
        140,
        0.025
      ),
    };

    const state = {
      power: 0,
      mana: 0,
      totalPower: 0,
      clickPower: 1,
      buyAmount: 1,
      activeQuickslot: 0,
      quickslots: ["spell1", ...Array.from({ length: spellQuickslotCount - 1 }, () => null)],
      spellCasts: 0,
      activeSpells: {},
      structures: Object.fromEntries(Object.keys(structureData).map((k) => [k, 0])),
      equipment: Object.fromEntries(Object.keys(gearSlotData).map((k) => [k, null])),
      ownedGear: {},
      gearLevels: {},
      equipmentLevelingEnabled: false,
      levelProgressPower: 0,
      upgrades: Object.fromEntries(Object.keys(upgradeData).map((k) => [k, 0])),
      revealedUpgrades: Object.fromEntries(Object.keys(upgradeData).map((k) => [k, false])),
      achievements: Object.fromEntries(achievementData.map((a) => [a.key, false])),
      pets: Object.fromEntries(Object.keys(petData).map((k) => [k, { level: 1, xp: 0 }])),
      petEquipped: ["emberFox", "astralOwl"],
      lastTick: Date.now(),
      lastSavedAt: null,
      log: [{ text: "Welcome, wizard. Your tower awaits.", klass: "" }],
      playerLevel: 1,
      levelBonus: 0,
      towerDefense: {
        wave: 1,
        breaches: 0,
        enemyHp: 20,
        enemyMaxHp: 20,
        enemyProgress: 0,
        spellPressure: 0,
        spellFreezeSec: 0,
      },
    };

    const els = {
      power: document.getElementById("power"),
      totalPower: document.getElementById("totalPower"),
      mps: document.getElementById("mps"),
      rank: document.getElementById("rank"),
      playerLevel: document.getElementById("playerLevel"),
      levelProfitBonus: document.getElementById("levelProfitBonus"),
      levelProgressFill: document.getElementById("levelProgressFill"),
      levelProgressText: document.getElementById("levelProgressText"),
      manaMirror: document.getElementById("manaMirror"),
      clickGain: document.getElementById("clickGain"),
      activeSpellName: document.getElementById("activeSpellName"),
      spellPower: document.getElementById("spellPower"),
      spellTime: document.getElementById("spellTime"),
      achievementPopups: document.getElementById("achievementPopups"),
      clickBtn: document.getElementById("clickBtn"),
      quickslots: document.getElementById("quickslots"),
      tdWave: document.getElementById("tdWave"),
      tdBreaches: document.getElementById("tdBreaches"),
      tdProgress: document.getElementById("tdProgress"),
      tdEnemyHp: document.getElementById("tdEnemyHp"),
      tdEnemyInfo: document.getElementById("tdEnemyInfo"),
      tdDps: document.getElementById("tdDps"),
      tdSpellBonus: document.getElementById("tdSpellBonus"),
      tdReward: document.getElementById("tdReward"),
      tdWaveFill: document.getElementById("tdWaveFill"),
      tdEnemyIcon: document.getElementById("tdEnemyIcon"),
      tdPowerWarning: document.getElementById("tdPowerWarning"),
      spellSlotModal: document.getElementById("spellSlotModal"),
      spellSlotModalTitle: document.getElementById("spellSlotModalTitle"),
      spellSlotModalBody: document.getElementById("spellSlotModalBody"),
      closeSpellSlotModalBtn: document.getElementById("closeSpellSlotModalBtn"),
      saveBtn: document.getElementById("saveBtn"),
      resetBtn: document.getElementById("resetBtn"),
      buyToggle: document.getElementById("buyToggle"),
      structures: document.getElementById("structures"),
      equipmentSlots: document.getElementById("equipmentSlots"),
      equipmentBonus: document.getElementById("equipmentBonus"),
      equipmentLevelingToggle: document.getElementById("equipmentLevelingToggle"),
      upgrades: document.getElementById("upgrades"),
      showAllUpgradesBtn: document.getElementById("showAllUpgradesBtn"),
      upgradeListModal: document.getElementById("upgradeListModal"),
      closeUpgradeListBtn: document.getElementById("closeUpgradeListBtn"),
      upgradeListBody: document.getElementById("upgradeListBody"),
      gearModal: document.getElementById("gearModal"),
      gearModalTitle: document.getElementById("gearModalTitle"),
      gearModalBody: document.getElementById("gearModalBody"),
      closeGearModalBtn: document.getElementById("closeGearModalBtn"),
      achievements: document.getElementById("achievements"),
      pets: document.getElementById("pets"),
      petSlotsInfo: document.getElementById("petSlotsInfo"),
      log: document.getElementById("log"),
    };

    let previousUpgradeRenderKey = "";
    let activeGearSlot = null;
    let activeSpellSlotPicker = 0;

    function format(num) {
      if (num < 1000) return num.toFixed(1).replace(/\.0$/, "");
      const units = ["K", "M", "B", "T", "Qa", "Qi"];
      let value = num;
      let idx = -1;
      while (value >= 1000 && idx < units.length - 1) {
        value /= 1000;
        idx += 1;
      }
      return `${value.toFixed(2)}${units[idx]}`;
    }

    const arcaneRankTitles = [
      "Novice", "Initiate", "Scholar", "Adept", "Master", "Archmage", "Grand Archmage",
      ...Array.from({ length: 50 }, (_, idx) => `Eternal Arcanist ${idx + 1}`),
    ];

    const arcaneRankTiers = arcaneRankTitles.map((name, idx) => {
      const threshold = idx === 0 ? 0 : Math.floor(300 * Math.pow(1.7, idx - 1));
      return {
        name,
        threshold,
        buffs: {
          mpsMult: 1 + (idx * 0.03),
          spellPowerMult: 1 + (idx * 0.025),
          manaCostMult: Math.max(0.45, 1 - (idx * 0.01)),
        },
      };
    });

    function getArcaneRank(totalPower) {
      let tier = arcaneRankTiers[0];
      for (const entry of arcaneRankTiers) {
        if (totalPower >= entry.threshold) tier = entry;
        else break;
      }
      return tier;
    }

    function rankFromPower(totalPower) {
      return getArcaneRank(totalPower).name;
    }

    function addLog(message, klass = "") {
      const stamped = `[${new Date().toLocaleTimeString()}] ${message}`;
      state.log.unshift({ text: stamped, klass });
      state.log = state.log.slice(0, 90);
    }


    function upgradeLevel(key) {
      return Number(state.upgrades[key] || 0);
    }

    function hasUpgrade(key) {
      return upgradeLevel(key) > 0;
    }

    function getUpgradeCost(key) {
      const up = upgradeData[key];
      if (!up) return Infinity;
      const level = upgradeLevel(key);
      if (!up.repeatable && level > 0) return Infinity;
      const growth = up.growth || 1;
      return Math.floor(up.cost * Math.pow(growth, level));
    }

    function meetsUpgradeRequirement(key) {
      const up = upgradeData[key];
      if (!up || typeof up.requirement !== "function") return true;
      return up.requirement(state);
    }

    function getStructureCost(key, levelOffset = 0) {
      const data = structureData[key];
      const level = state.structures[key] + levelOffset;
      return Math.floor(data.baseCost * Math.pow(data.growth, level));
    }

    function getBulkStructureCost(key, amount) {
      let total = 0;
      for (let i = 0; i < amount; i += 1) {
        total += getStructureCost(key, i);
      }
      return total;
    }

    function productionMultiplier() {
      let mult = 1;
      if (hasUpgrade("leylineBinding")) mult *= 1.25;
      if (hasUpgrade("crystallizedThought")) mult *= 1.5;
      if (hasUpgrade("archmageSigil")) mult *= 2.2;
      if (hasUpgrade("planarRefinery")) mult *= 2.8;
      if (hasUpgrade("singularityCore")) mult *= 4;
      if (state.achievements.mana1k) mult *= 1.05;
      if (state.achievements.mana20k) mult *= 1.1;
      if (state.achievements.mana250k) mult *= 1.15;
      if (state.achievements.mana2m) mult *= 1.25;
      if (state.achievements.towerTycoon) mult *= 1.2;
      return mult;
    }

    function getLevelUpCost(level) {
      const safeLevel = Math.max(1, Math.floor(level));
      return Math.floor(120 * Math.pow(1.9, safeLevel - 1));
    }

    function estimateLevelFromTotalPower(totalPower) {
      let level = 1;
      let progressPower = Math.max(0, totalPower);
      while (level < 500) {
        const cost = getLevelUpCost(level);
        if (progressPower < cost) break;
        progressPower -= cost;
        level += 1;
      }
      return { level, progressPower };
    }

    function levelProgress(level, progressPower) {
      const needed = getLevelUpCost(level);
      const current = Math.max(0, progressPower);
      const pct = Math.max(0, Math.min(1, current / needed));
      return { needed, current, pct };
    }

    function getPetSlotLimit() {
      return state.playerLevel >= 30 ? 3 : 2;
    }

    function petState(petKey) {
      if (!state.pets[petKey]) state.pets[petKey] = { level: 1, xp: 0 };
      return state.pets[petKey];
    }

    function petXpNeeded(level, xpScale = 1) {
      return Math.floor(40 * Math.pow(1.5, Math.max(0, level - 1)) * xpScale);
    }

    function getPetModifiers() {
      const mods = { production: 1, spell: 1, manaGain: 1, petXp: 1, offlineMana: 1 };
      for (const petKey of state.petEquipped) {
        const pet = petData[petKey];
        if (!pet) continue;
        const info = petState(petKey);
        pet.apply(mods, pet.bonus(info.level));
      }
      return mods;
    }

    function grantPetXp(amount) {
      if (amount <= 0 || state.petEquipped.length === 0) return;
      const share = amount * getPetModifiers().petXp / state.petEquipped.length;
      for (const petKey of state.petEquipped) {
        const pet = petData[petKey];
        if (!pet) continue;
        const info = petState(petKey);
        info.xp += share;
        let leveled = false;
        while (info.xp >= petXpNeeded(info.level, pet.xpScale)) {
          info.xp -= petXpNeeded(info.level, pet.xpScale);
          info.level += 1;
          leveled = true;
        }
        if (leveled) addLog(`${pet.name} reached level ${info.level}.`, "ok");
      }
    }

    function togglePetEquip(petKey) {
      if (!petData[petKey] || !isPetUnlocked(petKey)) return;
      if (state.petEquipped.includes(petKey)) {
        state.petEquipped = state.petEquipped.filter((key) => key !== petKey);
        return;
      }
      if (state.petEquipped.length >= getPetSlotLimit()) return;
      state.petEquipped.push(petKey);
    }

    function getStructureSpecificMultiplier(structureKey) {
      let mult = 1;
      for (const [upKey, level] of Object.entries(state.upgrades)) {
        if (!level) continue;
        const up = upgradeData[upKey];
        if (!up || up.structureTarget !== structureKey) continue;
        mult *= 1 + (up.structureBonus || 0);
      }
      return mult;
    }

    function getMps() {
      let total = 0;
      for (const [key, amount] of Object.entries(state.structures)) {
        total += amount * structureData[key].mps * getStructureSpecificMultiplier(key);
      }
      const infusionBonus = 1 + (upgradeLevel("manaInfusion") * 0.06);
      const levelBonus = 1 + (Math.max(1, state.playerLevel || 1) - 1) * 0.05;
      const rankBuff = getArcaneRank(state.totalPower).buffs.mpsMult;
      return total * productionMultiplier() * infusionBonus * gearProfitMultiplier() * levelBonus * rankBuff * getPetModifiers().production;
    }

    function findGear(slot, gearId) {
      return (gearData[slot] || []).find((gear) => gear.id === gearId) || null;
    }

    function gearProfitMultiplier() {
      let bonus = 0;
      for (const [slot, gearId] of Object.entries(state.equipment)) {
        const gear = findGear(slot, gearId);
        if (!gear) continue;
        const level = gearLevel(gear.id);
        const levelMult = 1 + ((level - 1) * 0.35);
        bonus += gear.profitBonus * levelMult;
      }
      return 1 + bonus;
    }

    function gearLevel(gearId) {
      return Math.max(1, Number(state.gearLevels[gearId] || 1));
    }

    function getGearLevelCost(gearId) {
      const gear = Object.values(gearData).flat().find((entry) => entry.id === gearId);
      if (!gear) return Infinity;
      const level = gearLevel(gearId);
      const base = Math.max(1000, Math.floor(gear.cost * 1.2));
      return Math.floor(base * Math.pow(2.75, level - 1));
    }

    function applyLevelUps() {
      let gained = 0;
      while (state.levelProgressPower >= getLevelUpCost(state.playerLevel) && state.playerLevel < 500) {
        state.levelProgressPower -= getLevelUpCost(state.playerLevel);
        state.playerLevel += 1;
        gained += 1;
      }
      state.levelBonus = (state.playerLevel - 1) * 0.05;
      if (gained > 0) {
        addLog(`Level up! Reached level ${state.playerLevel}. Profit bonus is now +${(state.levelBonus * 100).toFixed(0)}%.`, "ok");
      }
    }

    function upgradeGearLevel(gearId) {
      if (!state.equipmentLevelingEnabled) return;
      if (!state.ownedGear[gearId]) return;
      const cost = getGearLevelCost(gearId);
      if (!canAfford(cost)) return;
      state.power -= cost;
      state.gearLevels[gearId] = gearLevel(gearId) + 1;
      addLog(`Empowered ${gearId} to level ${state.gearLevels[gearId]} for ${format(cost)} power.`, "ok");
      renderGearModal();
      render();
    }

    function spellCost(key) {
      const base = spellData[key].manaCost;
      if (spellData[key].unlockLevel === 0) return 0;
      const reduction = hasUpgrade("manaCompression") ? 0.8 : 1;
      const singularityDiscount = hasUpgrade("singularityCore") ? 0.75 : 1;
      const masteryDiscount = state.achievements.spellweaver ? 0.9 : 1;
      const ritualReduction = Math.max(0.55, 1 - (upgradeLevel("ritualEconomy") * 0.03));
      return Math.floor(base * reduction * singularityDiscount * masteryDiscount * ritualReduction * getArcaneRank(state.totalPower).buffs.manaCostMult);
    }

    function spellPower(key) {
      let power = spellData[key].basePower;
      if (key === "bolt") power = Math.max(power, state.clickPower);
      if (hasUpgrade("runeEtching")) power *= 1.3;
      if (hasUpgrade("tempestMastery") && (key === "lightning" || key === "meteor")) power *= 1.9;
      if (hasUpgrade("celestialLattice")) power *= 2.2;
      if (state.achievements.skyLord) power *= 1.15;
      power *= 1 + (upgradeLevel("arcaneStudy") * 0.08);
      power *= getArcaneRank(state.totalPower).buffs.spellPowerMult;
      power *= getPetModifiers().spell;
      return power;
    }

    function isSpellUnlocked(key) {
      return state.playerLevel >= spellData[key].unlockLevel;
    }

    function selectedSpellKey() {
      return state.quickslots[state.activeQuickslot] || null;
    }

    function tdTowerDps() {
      const totalPowerScale = Math.pow(Math.max(1, state.totalPower), 0.22);
      const structureScale = 1 + (Object.values(state.structures).reduce((sum, amount) => sum + amount, 0) * 0.02);
      const spellScale = 1 + Math.min(2.5, state.towerDefense.spellPressure * 0.2);
      return totalPowerScale * structureScale * spellScale;
    }

    function tdWaveValue(wave = state.towerDefense.wave) {
      return 18 + (wave * 5);
    }

    function tdRequiredPower(wave = state.towerDefense.wave) {
      return 10 + (wave * 2.8);
    }

    function tdPowerRatio() {
      return tdTowerDps() / Math.max(1, tdRequiredPower(state.towerDefense.wave));
    }

    function spawnTdEnemy(nextWave = state.towerDefense.wave) {
      const hp = tdWaveValue(nextWave) * Math.pow(1.2, Math.max(0, nextWave - 1));
      state.towerDefense.enemyMaxHp = hp;
      state.towerDefense.enemyHp = hp;
      state.towerDefense.enemyProgress = 0;
    }

    function updateTowerDefense(delta) {
      if (state.towerDefense.breaches >= tdMaxBreaches) return;
      if (state.towerDefense.spellFreezeSec > 0) {
        state.towerDefense.spellFreezeSec = Math.max(0, state.towerDefense.spellFreezeSec - delta);
      }
      const powerRatio = tdPowerRatio();
      const breachPressure = powerRatio < 1 ? 1 + ((1 - powerRatio) * 0.9) : 1;
      const speed = (0.025 + (state.towerDefense.wave * 0.0035)) * breachPressure * (state.towerDefense.spellFreezeSec > 0 ? 0.2 : 1);
      state.towerDefense.enemyProgress += speed * delta;
      state.towerDefense.enemyHp -= tdTowerDps() * delta;

      if (state.towerDefense.enemyHp <= 0) {
        const rewardPower = state.towerDefense.enemyMaxHp * 1.6;
        const rewardMana = Math.max(1, state.towerDefense.wave * 1.15);
        state.power += rewardPower;
        state.totalPower += rewardPower;
        state.levelProgressPower += rewardPower;
        state.mana += rewardMana;
        state.towerDefense.wave += 1;
        spawnTdEnemy(state.towerDefense.wave);
      } else if (state.towerDefense.enemyProgress >= 1) {
        state.towerDefense.breaches += 1;
        state.towerDefense.spellPressure = Math.max(0, state.towerDefense.spellPressure - 0.6);
        spawnTdEnemy(state.towerDefense.wave);
      }
    }

    function canAfford(cost) {
      return state.power >= cost;
    }

    function canAffordMana(cost) {
      return state.mana >= cost;
    }

    function buyStructure(key) {
      const amount = state.buyAmount;
      const totalCost = getBulkStructureCost(key, amount);
      if (!canAfford(totalCost)) return;

      state.power -= totalCost;
      state.structures[key] += amount;
      addLog(`Purchased ${amount} ${structureData[key].name}${amount > 1 ? "s" : ""}.`, "ok");
      render();
    }

    function buyUpgrade(key) {
      const up = upgradeData[key];
      if (!up || !meetsUpgradeRequirement(key)) return;
      const cost = getUpgradeCost(key);
      if (!canAfford(cost)) return;

      state.power -= cost;
      state.upgrades[key] = upgradeLevel(key) + 1;
      up.apply(state);
      previousUpgradeRenderKey = "";

      if (up.repeatable) {
        addLog(`Studied ${up.name} (Level ${upgradeLevel(key)}).`, "ok");
      } else {
        addLog(`Learned upgrade: ${up.name}. ${up.effect}`, "ok");
      }
      render();
    }

    function buyGear(slot, gearId) {
      const gear = findGear(slot, gearId);
      if (!gear) return;
      const alreadyOwned = Boolean(state.ownedGear[gearId]);
      if (!alreadyOwned && !canAfford(gear.cost)) return;

      if (!alreadyOwned) {
        state.power -= gear.cost;
        state.ownedGear[gearId] = true;
        state.gearLevels[gearId] = Math.max(1, Number(state.gearLevels[gearId] || 1));
        addLog(`Purchased ${gear.name} for ${format(gear.cost)} power.`, "ok");
      }

      state.equipment[slot] = gearId;
      addLog(`Equipped ${gear.name} in ${gearSlotData[slot].name}.`, "warn");
      renderGearModal();
      render();
    }

    function unlockAchievement(key) {
      if (state.achievements[key]) return;
      state.achievements[key] = true;
      const achievement = achievementData.find((a) => a.key === key);
      if (key === "golem3") state.clickPower += 15;
      if (key === "voidCaller") state.clickPower += 40;
      addLog(`Achievement unlocked: ${achievement.name} (${achievement.reward})`, "ok");
      showAchievementPopup(achievement);
    }

    function canClaimAchievement(key) {
      const achievement = achievementData.find((entry) => entry.key === key);
      if (!achievement || state.achievements[key]) return false;
      return achievement.test(state);
    }

    function claimAchievement(key) {
      if (!canClaimAchievement(key)) return;
      unlockAchievement(key);
      render();
    }

    function autoUnlockAchievements() {
      let changed = false;
      for (const achievement of achievementData) {
        if (!state.achievements[achievement.key] && achievement.test(state)) {
          unlockAchievement(achievement.key);
          changed = true;
        }
      }
      return changed;
    }

    function showAchievementPopup(achievement) {
      const popup = document.createElement("div");
      popup.className = "achievement-popup";
      popup.innerHTML = `
        <img src="${achievement.image}" alt="${achievement.name} icon" />
        <div>
          <strong>Achievement Unlocked</strong>
          <div>${achievement.name}</div>
        </div>
      `;
      els.achievementPopups.appendChild(popup);
      setTimeout(() => {
        popup.remove();
      }, 3200);
    }

    function activeSpellRemainingMs(spellKey, now = Date.now()) {
      const entry = state.activeSpells[spellKey];
      if (!entry) return 0;
      return Math.max(0, Number(entry.expiresAt || 0) - now);
    }

    function cleanupExpiredSpells(now = Date.now()) {
      for (const key of Object.keys(state.activeSpells)) {
        if (activeSpellRemainingMs(key, now) <= 0) delete state.activeSpells[key];
      }
    }

    function getActiveSpellPps(now = Date.now()) {
      cleanupExpiredSpells(now);
      let bonus = 0;
      for (const entry of Object.values(state.activeSpells)) {
        bonus += Number(entry.powerPerSecond || 0);
      }
      return bonus;
    }

    function castSpell(spellKey = selectedSpellKey()) {
      const key = spellData[spellKey] ? spellKey : null;
      if (!key) return;
      if (!isSpellUnlocked(key)) return;
      const cost = spellCost(key);
      if (!canAffordMana(cost)) return;

      const spell = spellData[key];
      const pps = spellPower(key);
      const now = Date.now();
      state.mana -= cost;
      state.activeSpells[key] = {
        powerPerSecond: pps,
        expiresAt: now + (spell.durationSec * 1000),
      };
      state.spellCasts += 1;
      state.towerDefense.spellPressure = Math.min(12, state.towerDefense.spellPressure + 0.55);
      state.towerDefense.spellFreezeSec = Math.max(state.towerDefense.spellFreezeSec, 0.35 + (pps / Math.max(1, state.towerDefense.enemyMaxHp)));
      state.towerDefense.enemyHp = Math.max(0, state.towerDefense.enemyHp - (pps * 0.9));
      grantPetXp(Math.max(1, pps * 0.02));
      state.activeQuickslot = Math.min(Math.max(0, state.activeQuickslot), spellQuickslotCount - 1);
      if (state.spellCasts % 25 === 0) {
        addLog(`Arcane rhythm! ${state.spellCasts} spells cast so far.`, "warn");
      }
      render();
    }

    function gatherPower() {
      const gain = Math.max(1, state.clickPower);
      state.power += gain;
      state.totalPower += gain;
      state.levelProgressPower += gain;
      grantPetXp(Math.max(0.5, gain * 0.015));
      applyLevelUps();
      render();
    }

    function saveGame(showToast = true) {
      const payload = { ...state, totalMana: state.totalPower, power: state.power, mana: state.mana, lastTick: Date.now(), log: state.log.slice(0, 60) };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      state.lastSavedAt = Date.now();
      if (showToast) addLog("Game saved.", "ok");
      render();
    }

    function normalizeLoadedState(data) {
      state.power = Number((data.power ?? data.mana) || 0);
      state.mana = Number(data.mana || 0);
      state.totalPower = Number((data.totalPower ?? data.totalMana) || 0);
      state.clickPower = Number(data.clickPower || 1);
      state.buyAmount = [1, 10, 25].includes(Number(data.buyAmount)) ? Number(data.buyAmount) : 1;
      state.activeQuickslot = Number.isInteger(data.activeQuickslot) ? Math.min(Math.max(0, data.activeQuickslot), spellQuickslotCount - 1) : 0;
      const loadedSlots = Array.isArray(data.quickslots) ? data.quickslots : [];
      state.quickslots = Array.from({ length: spellQuickslotCount }, (_, idx) => {
        const key = loadedSlots[idx];
        return typeof key === "string" && spellData[key] ? key : null;
      });
      if (!Array.isArray(data.quickslots) && typeof data.activeSpell === "string" && spellData[data.activeSpell]) {
        state.quickslots[0] = data.activeSpell;
      }
      if (!state.quickslots.some((key) => typeof key === "string" && spellData[key])) {
        state.quickslots[0] = "spell1";
      }
      state.spellCasts = Number(data.spellCasts || 0);
      state.activeSpells = {};
      for (const [key, entry] of Object.entries(data.activeSpells || {})) {
        if (!spellData[key]) continue;
        const expiresAt = Number(entry?.expiresAt || 0);
        const powerPerSecond = Number(entry?.powerPerSecond || 0);
        if (expiresAt > Date.now() && powerPerSecond > 0) {
          state.activeSpells[key] = { expiresAt, powerPerSecond };
        }
      }

      for (const key of Object.keys(state.structures)) {
        state.structures[key] = Number(data.structures?.[key] || 0);
      }
      for (const key of Object.keys(state.equipment)) {
        const gearId = data.equipment?.[key] || null;
        state.equipment[key] = findGear(key, gearId) ? gearId : null;
      }
      state.ownedGear = {};
      state.gearLevels = {};
      state.equipmentLevelingEnabled = Boolean(data.equipmentLevelingEnabled);
      const loadedOwnedGear = data.ownedGear || {};
      for (const slotItems of Object.values(gearData)) {
        for (const gear of slotItems) {
          if (loadedOwnedGear[gear.id]) state.ownedGear[gear.id] = true;
          if (state.ownedGear[gear.id]) {
            const loadedLevel = Number(data.gearLevels?.[gear.id] || 1);
            state.gearLevels[gear.id] = Math.max(1, loadedLevel);
          }
        }
      }
      for (const equippedId of Object.values(state.equipment)) {
        if (equippedId) {
          state.ownedGear[equippedId] = true;
          state.gearLevels[equippedId] = Math.max(1, Number(state.gearLevels[equippedId] || 1));
        }
      }
      for (const key of Object.keys(state.upgrades)) {
        const loaded = data.upgrades?.[key];
        state.upgrades[key] = loaded === true ? 1 : Number(loaded || 0);
      }
      for (const key of Object.keys(state.revealedUpgrades)) {
        state.revealedUpgrades[key] = Boolean(data.revealedUpgrades?.[key]) || state.upgrades[key] > 0;
      }
      previousUpgradeRenderKey = "";
      for (const key of Object.keys(state.achievements)) {
        state.achievements[key] = Boolean(data.achievements?.[key]);
      }
      for (const petKey of Object.keys(petData)) {
        const loadedPet = data.pets?.[petKey];
        state.pets[petKey] = {
          level: Math.max(1, Math.floor(Number(loadedPet?.level || 1))),
          xp: Math.max(0, Number(loadedPet?.xp || 0)),
        };
      }
      const loadedEquipped = Array.isArray(data.petEquipped)
        ? data.petEquipped.filter((petKey) => petData[petKey])
        : [];
      const slotLimit = getPetSlotLimit();
      state.petEquipped = loadedEquipped.slice(0, slotLimit);
      if (state.petEquipped.length === 0) {
        state.petEquipped = Object.keys(petData).slice(0, slotLimit);
      }
      const loadedLevel = Number(data.playerLevel || 0);
      const loadedProgress = Number(data.levelProgressPower);
      if (loadedLevel > 0) {
        state.playerLevel = Math.floor(loadedLevel);
        state.levelProgressPower = Number.isFinite(loadedProgress) ? Math.max(0, loadedProgress) : 0;
      } else {
        const estimated = estimateLevelFromTotalPower(state.totalPower);
        state.playerLevel = estimated.level;
        state.levelProgressPower = estimated.progressPower;
      }
      state.levelBonus = Number.isFinite(data.levelBonus) ? Number(data.levelBonus) : (state.playerLevel - 1) * 0.05;
      const loadedTd = data.towerDefense || {};
      state.towerDefense = {
        wave: Math.max(1, Math.floor(Number(loadedTd.wave || 1))),
        breaches: Math.max(0, Math.floor(Number(loadedTd.breaches || 0))),
        enemyHp: Math.max(1, Number(loadedTd.enemyHp || tdWaveValue(Number(loadedTd.wave || 1)))),
        enemyMaxHp: Math.max(1, Number(loadedTd.enemyMaxHp || tdWaveValue(Number(loadedTd.wave || 1)))),
        enemyProgress: Math.min(1, Math.max(0, Number(loadedTd.enemyProgress || 0))),
        spellPressure: Math.max(0, Number(loadedTd.spellPressure || 0)),
        spellFreezeSec: Math.max(0, Number(loadedTd.spellFreezeSec || 0)),
      };

      state.log = Array.isArray(data.log) && data.log.length
        ? data.log.map((entry) => (typeof entry === "string" ? { text: entry, klass: "" } : entry))
        : [{ text: "Welcome back, wizard.", klass: "" }];
    }

    function applyOfflineProgress(previousTick) {
      if (!previousTick) return;
      const elapsedSeconds = Math.min((Date.now() - previousTick) / 1000, 6 * 60 * 60);
      if (elapsedSeconds <= 2) return;
      const gained = getMps() * elapsedSeconds;
      if (gained <= 0) return;

      state.power += gained;
      state.totalPower += gained;
      state.levelProgressPower += gained;
      state.mana += gained * 0.25 * getPetModifiers().offlineMana;
      grantPetXp(gained * 0.0012);
      applyLevelUps();
      addLog(`You were away for ${Math.floor(elapsedSeconds)}s and gained ${format(gained)} power and ${format(gained * 0.25 * getPetModifiers().offlineMana)} mana.`, "warn");
    }

    function loadGame() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;

      try {
        const parsed = JSON.parse(raw);
        const previousTick = Number(parsed.lastTick);
        normalizeLoadedState(parsed);
        applyOfflineProgress(previousTick);
        state.lastTick = Date.now();
        addLog("Save loaded.", "ok");
      } catch {
        addLog("Save file corrupted. Starting fresh.", "danger");
      }
    }

    function resetGame() {
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }

    function renderStructures() {
      els.structures.innerHTML = "";
      for (const [key, data] of Object.entries(structureData)) {
        const owned = state.structures[key];
        const nextCost = getStructureCost(key, 0);
        const bulkCost = getBulkStructureCost(key, state.buyAmount);
        const disabled = !canAfford(bulkCost);

        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${data.image}" alt="${data.name} icon" title="${data.tooltip}" />
          <div>
            <div class="name">${data.name} <span class="pill">Owned: ${owned}</span></div>
            <div class="meta">+${format(data.mps)}/sec each ‚Ä¢ Next: ${format(nextCost)} power</div>
            <div class="meta">Buy ${state.buyAmount}: ${format(bulkCost)} power</div>
          </div>
          <button ${disabled ? "disabled" : ""}>Buy x${state.buyAmount}</button>
        `;

        const buyButton = card.querySelector("button");
        buyButton.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          buyStructure(key);
        });
        els.structures.appendChild(card);
      }
    }

    function renderEquipment() {
      els.equipmentSlots.innerHTML = "";
      const totalBonusPct = (gearProfitMultiplier() - 1) * 100;
      els.equipmentBonus.textContent = `Current gear bonus: +${totalBonusPct.toFixed(1)}% structure profits`;

      for (const [slot, slotMeta] of Object.entries(gearSlotData)) {
        const gearId = state.equipment[slot];
        const gear = findGear(slot, gearId);

        const slotButton = document.createElement("button");
        slotButton.type = "button";
        slotButton.className = `gear-slot ${gear ? "" : "empty"}`;
        const level = gear ? gearLevel(gear.id) : 0;
        const leveledBonus = gear ? gear.profitBonus * (1 + ((level - 1) * 0.35)) : 0;
        slotButton.innerHTML = `
          <div class="slot-type">${slotMeta.icon} ${slotMeta.name}</div>
          <div class="slot-equipped">${gear ? `<img src="${gear.icon}" alt="${gear.name} icon" />` : ""}<div class="slot-item">${gear ? gear.name : "Empty Slot"}</div></div>
          <div class="slot-profit">${gear ? `Lv ${level} ‚Ä¢ +${(leveledBonus * 100).toFixed(1)}% profit` : "Click to browse gear"}</div>
        `;
        slotButton.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          openGearModal(slot);
        });
        els.equipmentSlots.appendChild(slotButton);
      }
    }

    function renderPets() {
      els.pets.innerHTML = "";
      const slotLimit = getPetSlotLimit();
      els.petSlotsInfo.textContent = `Equipped: ${state.petEquipped.length} / ${slotLimit} slots`;

      const petEntries = Object.entries(petData).sort(([leftKey, leftPet], [rightKey, rightPet]) => {
        const leftEquipped = state.petEquipped.includes(leftKey);
        const rightEquipped = state.petEquipped.includes(rightKey);
        if (leftEquipped !== rightEquipped) return leftEquipped ? -1 : 1;
        const leftUnlocked = isPetUnlocked(leftKey);
        const rightUnlocked = isPetUnlocked(rightKey);
        if (leftUnlocked !== rightUnlocked) return leftUnlocked ? -1 : 1;
        if ((leftPet.tier || 1) !== (rightPet.tier || 1)) return (leftPet.tier || 1) - (rightPet.tier || 1);
        return leftPet.name.localeCompare(rightPet.name);
      });

      for (const [petKey, pet] of petEntries) {
        const info = petState(petKey);
        const needed = petXpNeeded(info.level, pet.xpScale);
        const pct = Math.max(0, Math.min(100, (info.xp / needed) * 100));
        const bonusPct = pet.bonus(info.level) * 100;
        const equipped = state.petEquipped.includes(petKey);
        const unlocked = isPetUnlocked(petKey);
        const blocked = !equipped && (state.petEquipped.length >= slotLimit || !unlocked);
        const unlockText = !unlocked && pet.unlockFrom
          ? `Unlock: ${petData[pet.unlockFrom].name} Lv 99`
          : "";
        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${pet.image}" alt="${pet.name} icon" title="${pet.bonusText}" />
          <div>
            <div class="name">${pet.name} ${equipped ? '<span class="pill">Equipped</span>' : ""}</div>
            <div class="meta">Tier ${pet.tier || 1}</div>
            <div class="meta">Lv ${info.level} ‚Ä¢ ${pet.bonusText}: +${bonusPct.toFixed(1)}%</div>
            <div class="meta">XP ${format(info.xp)} / ${format(needed)}</div>
            ${unlockText ? `<div class="meta">${unlockText}</div>` : ""}
            <div class="level-bar"><span style="width:${pct.toFixed(1)}%"></span></div>
          </div>
          <button ${blocked ? "disabled" : ""}>${equipped ? "Unequip" : (unlocked ? "Equip" : "Locked")}</button>
        `;

        card.querySelector("button").addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          togglePetEquip(petKey);
          render();
        });
        els.pets.appendChild(card);
      }
    }

    function renderUpgrades() {
      const visibleEntries = [];
      for (const [key, up] of Object.entries(upgradeData)) {
        const level = upgradeLevel(key);
        const nextCost = getUpgradeCost(key);
        const requirementMet = meetsUpgradeRequirement(key);
        const revealFactor = up.repeatable ? 0.5 : 1;
        const canReveal = Number.isFinite(nextCost) && state.power >= nextCost * revealFactor;
        const alreadyRevealed = Boolean(state.revealedUpgrades[key]) || level > 0;
        if (!alreadyRevealed && requirementMet && canReveal) {
          state.revealedUpgrades[key] = true;
        }
        if ((!up.repeatable && level > 0) || !requirementMet || (!state.revealedUpgrades[key] && !canReveal)) continue;
        visibleEntries.push({ key, up, nextCost, requirementMet });
      }

      const renderKey = JSON.stringify(visibleEntries.map((entry) => {
        const affordable = canAfford(entry.nextCost);
        return [entry.key, affordable ? 1 : 0];
      }));
      if (renderKey === previousUpgradeRenderKey) return;
      previousUpgradeRenderKey = renderKey;

      els.upgrades.innerHTML = "";
      for (const { key, up, nextCost, requirementMet } of visibleEntries) {
        const disabled = !requirementMet || !canAfford(nextCost);
        const card = document.createElement("div");
        card.className = `upgrade-icon${disabled ? " disabled" : ""}`;
        card.tabIndex = 0;
        card.setAttribute("role", "button");
        card.setAttribute("aria-label", `Buy upgrade ${up.name}`);
        card.setAttribute("aria-disabled", disabled ? "true" : "false");
        card.innerHTML = `
          <img class="item-icon" src="${up.image}" alt="${up.name} icon" />
          <div class="upgrade-tooltip">
            <b>${up.name}</b>
            <div>${up.effect}</div>
            ${up.repeatable ? `<div>Level: ${upgradeLevel(key)}</div>` : ""}
            <div>Cost: ${Number.isFinite(nextCost) ? format(nextCost) : "--"} power</div>
            ${up.requirementText ? `<div>Req: ${up.requirementText}${requirementMet ? "" : " (not met)"}</div>` : ""}
            <div>${up.tooltip}</div>
          </div>
        `;

        card.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (disabled) return;
          buyUpgrade(key);
        });

        card.addEventListener("keydown", (event) => {
          if (event.key !== "Enter" && event.key !== " ") return;
          event.preventDefault();
          if (disabled) return;
          buyUpgrade(key);
        });

        els.upgrades.appendChild(card);
      }

      if (visibleEntries.length === 0) {
        const empty = document.createElement("div");
        empty.className = "upgrade-empty";
        empty.textContent = "Earn more power and structures to reveal your next upgrades.";
        els.upgrades.appendChild(empty);
      }
    }

    function renderUpgradeListModal() {
      els.upgradeListBody.innerHTML = "";
      const entries = Object.entries(upgradeData).map(([key, up]) => {
        const level = upgradeLevel(key);
        const requirementMet = meetsUpgradeRequirement(key);
        const nextCost = getUpgradeCost(key);
        const lockedByRequirement = !requirementMet;
        const purchased = level > 0 && !up.repeatable;
        return { key, up, level, requirementMet, nextCost, lockedByRequirement, purchased };
      });

      for (const entry of entries) {
        const row = document.createElement("div");
        row.className = "upgrade-modal-item";
        const unlockText = entry.up.requirementText
          ? `${entry.up.requirementText}${entry.requirementMet ? "" : " (not met)"}`
          : "Reach enough power to reveal and afford this upgrade.";
        row.innerHTML = `
          <img class="item-icon" src="${entry.up.image}" alt="${entry.up.name} icon" />
          <div>
            <div class="name">${entry.up.name}</div>
            <div class="meta">${entry.up.effect}</div>
            <div class="meta">Cost: ${Number.isFinite(entry.nextCost) ? format(entry.nextCost) : "--"} power</div>
            <div class="meta">How to unlock: ${unlockText}</div>
            <div class="meta">${entry.up.tooltip}</div>
          </div>
          <div class="meta">${entry.purchased ? "Bought" : entry.lockedByRequirement ? "Locked" : "Available"}</div>
        `;
        els.upgradeListBody.appendChild(row);
      }
    }

    function openGearModal(slot) {
      activeGearSlot = slot;
      renderGearModal();
      els.gearModal.classList.remove("hidden");
    }

    function closeGearModal() {
      activeGearSlot = null;
      els.gearModal.classList.add("hidden");
    }

    function renderGearModal() {
      if (!activeGearSlot || !gearSlotData[activeGearSlot]) return;
      const slotMeta = gearSlotData[activeGearSlot];
      els.gearModalTitle.textContent = `${slotMeta.icon} ${slotMeta.name} Gear`;
      els.gearModalBody.innerHTML = "";

      const equippedId = state.equipment[activeGearSlot];
      for (const gear of gearData[activeGearSlot]) {
        const owned = Boolean(state.ownedGear[gear.id]);
        const equipped = equippedId === gear.id;
        const affordable = canAfford(gear.cost);
        const disabled = !owned && !affordable;
        const level = gearLevel(gear.id);
        const levelCost = getGearLevelCost(gear.id);
        const canLevel = state.equipmentLevelingEnabled && owned && canAfford(levelCost);
        const leveledBonus = gear.profitBonus * (1 + ((level - 1) * 0.35));

        const row = document.createElement("div");
        row.className = "upgrade-modal-item";
        row.innerHTML = `
          <img class="item-icon" src="${gear.icon || webIcon("üß∞")}" alt="${gear.name} icon" />
          <div>
            <div class="name">${gear.name} ${equipped ? '<span class="pill">Equipped</span>' : ""} ${owned && !equipped ? '<span class="pill">Owned</span>' : ""}</div>
            <div class="meta">Profit boost: +${(leveledBonus * 100).toFixed(1)}% (base ${(gear.profitBonus * 100).toFixed(1)}%)</div>
            <div class="meta">Cost: ${format(gear.cost)} power</div>
            <div class="meta">Level: ${level}${state.equipmentLevelingEnabled && owned ? ` ‚Ä¢ Next level cost: ${format(levelCost)} power` : ""}</div>
          </div>
          <div style="display:grid; gap:6px;">
            <button class="gear-buy-btn" ${disabled || equipped ? "disabled" : ""}>${owned ? "Equip" : "Buy"}</button>
            <button class="gear-level-btn" ${!canLevel ? "disabled" : ""}>Level Up</button>
          </div>
        `;
        row.querySelector(".gear-buy-btn").addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (disabled || equipped) return;
          buyGear(activeGearSlot, gear.id);
        });
        row.querySelector(".gear-level-btn").addEventListener("pointerdown", (event) => {
          event.preventDefault();
          event.stopPropagation();
          if (!canLevel) return;
          upgradeGearLevel(gear.id);
        });
        els.gearModalBody.appendChild(row);
      }
    }

    function openUpgradeListModal() {
      renderUpgradeListModal();
      els.upgradeListModal.classList.remove("hidden");
    }

    function closeUpgradeListModal() {
      els.upgradeListModal.classList.add("hidden");
    }

    function renderQuickslots() {
      els.quickslots.innerHTML = "";
      for (let idx = 0; idx < spellQuickslotCount; idx += 1) {
        const key = state.quickslots[idx];
        const spell = key ? spellData[key] : null;
        const unlocked = spell ? isSpellUnlocked(key) : false;
        const cost = spell ? spellCost(key) : 0;
        const canCast = spell && unlocked && canAffordMana(cost);

        const slot = document.createElement("button");
        slot.type = "button";
        slot.className = `quickslot ${state.activeQuickslot === idx ? "active" : ""}`;
        slot.innerHTML = `
          <span class="slot-key">${idx + 1}</span>
          <img src="${spell ? spell.image : webIcon("‚ùî")}" alt="${spell ? spell.name : "Unassigned spell slot"} icon" />
          <span>${spell ? spell.name : "Empty Slot"}</span>
          <span class="slot-cost">${spell ? (unlocked ? `${format(cost)} mana ‚Ä¢ ${activeSpellRemainingMs(key) > 0 ? `${(activeSpellRemainingMs(key) / 1000).toFixed(1)}s left` : `${spell.durationSec.toFixed(0)}s duration`}` : `Unlock Lv ${spell.unlockLevel}`) : "Click to assign"}</span>
        `;
        slot.title = spell ? (unlocked ? `Cast ${spell.name}` : `Unlock at level ${spell.unlockLevel}`) : "Assign a spell";
        slot.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          state.activeQuickslot = idx;
          openSpellSlotModal(idx);
        });
        slot.disabled = false;
        if (spell && !canCast) slot.classList.add("disabled");
        els.quickslots.appendChild(slot);
      }
    }

    function openSpellSlotModal(slotIndex) {
      activeSpellSlotPicker = slotIndex;
      const slotLabel = slotIndex + 1;
      els.spellSlotModalTitle.textContent = `Assign Spell to Slot ${slotLabel}`;
      renderSpellSlotModal();
      els.spellSlotModal.classList.remove("hidden");
    }

    function closeSpellSlotModal() {
      els.spellSlotModal.classList.add("hidden");
    }

    function assignSpellToSlot(slotIndex, spellKey) {
      state.quickslots[slotIndex] = spellKey;
      state.activeQuickslot = slotIndex;
      render();
    }

    function renderSpellSlotModal() {
      els.spellSlotModalBody.innerHTML = "";

      const clearRow = document.createElement("div");
      clearRow.className = "item";
      clearRow.innerHTML = `<img class="item-icon" src="${webIcon("‚ùå")}" alt="clear slot icon" /><div><div class="name">Clear Slot</div><div class="meta">Remove assigned spell from this quickslot.</div></div><button type="button">Clear</button>`;
      clearRow.querySelector("button").addEventListener("pointerdown", (event) => {
        event.preventDefault();
        assignSpellToSlot(activeSpellSlotPicker, null);
        closeSpellSlotModal();
      });
      els.spellSlotModalBody.appendChild(clearRow);

      for (const [key, spell] of Object.entries(spellData)) {
        const unlocked = isSpellUnlocked(key);
        const row = document.createElement("div");
        row.className = "item";
        row.innerHTML = `
          <img class="item-icon" src="${spell.image}" alt="${spell.name} icon" />
          <div>
            <div class="name">${spell.name}</div>
            <div class="meta">Level ${spell.unlockLevel} unlock ‚Ä¢ ${format(spell.basePower)} base power</div>
            <div class="meta">Cost: ${format(spellCost(key))} mana</div>
          </div>
          <button type="button" ${unlocked ? "" : "disabled"}>${unlocked ? "Assign" : "Locked"}</button>
        `;
        row.querySelector("button").addEventListener("pointerdown", (event) => {
          event.preventDefault();
          if (!unlocked) return;
          assignSpellToSlot(activeSpellSlotPicker, key);
          closeSpellSlotModal();
        });
        els.spellSlotModalBody.appendChild(row);
      }
    }

    function renderAchievements() {
      els.achievements.innerHTML = "";
      for (const achievement of achievementData) {
        const unlocked = state.achievements[achievement.key];
        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${achievement.image}" alt="${achievement.name} icon" title="${achievement.tooltip}" />
          <div>
            <div class="name">${achievement.name} ${unlocked ? '<span class="pill">Unlocked</span>' : ""}</div>
            <div class="meta">How to unlock: ${achievement.requirement}</div>
            <div class="meta">Reward: ${achievement.reward}</div>
          </div>
          <button disabled>${unlocked ? "Unlocked" : "Locked"}</button>
        `;
        els.achievements.appendChild(card);
      }
    }

    function renderLog() {
      els.log.innerHTML = state.log
        .map((entry) => `<div class="${entry.klass || ""}">${entry.text}</div>`)
        .join("");
    }

    function renderTowerDefense() {
      const td = state.towerDefense;
      const hpPct = Math.max(0, Math.min(100, (td.enemyHp / Math.max(1, td.enemyMaxHp)) * 100));
      const progressPct = Math.max(0, Math.min(100, td.enemyProgress * 100));
      const rewardPower = td.enemyMaxHp * 1.6;
      const rewardMana = Math.max(1, td.wave * 1.15);
      const requiredPower = tdRequiredPower(td.wave);
      const powerRatio = tdPowerRatio();
      const towerPowerLow = powerRatio < 1;
      els.tdWave.textContent = String(td.wave);
      els.tdBreaches.textContent = String(td.breaches);
      els.tdProgress.style.width = `${progressPct.toFixed(2)}%`;
      els.tdEnemyHp.style.width = `${hpPct.toFixed(2)}%`;
      els.tdWaveFill.style.width = `${progressPct.toFixed(2)}%`;
      els.tdEnemyIcon.style.left = `calc(${progressPct.toFixed(2)}% - 12px)`;
      els.tdWaveFill.classList.toggle("low-power", towerPowerLow);
      if (towerPowerLow) {
        const pct = Math.max(0, Math.min(100, powerRatio * 100));
        els.tdPowerWarning.textContent = `Tower power low (${pct.toFixed(0)}% of needed). Breach chance increased.`;
      } else {
        els.tdPowerWarning.textContent = `Tower power stable (${format(tdTowerDps())} / ${format(requiredPower)} recommended).`;
      }
      if (td.breaches >= tdMaxBreaches) {
        els.tdEnemyInfo.textContent = "The barrier is overloaded (5 breaches). Keep casting and growing power, then refresh to restart this lane.";
      } else {
        els.tdEnemyInfo.textContent = `Wave ${td.wave} invader ‚Ä¢ ${format(td.enemyHp)} / ${format(td.enemyMaxHp)} HP ‚Ä¢ ${(progressPct).toFixed(0)}% to breach${td.spellFreezeSec > 0 ? ` ‚Ä¢ Frozen ${td.spellFreezeSec.toFixed(1)}s` : ""}`;
      }
      els.tdDps.textContent = `${format(tdTowerDps())} damage/sec`;
      els.tdSpellBonus.textContent = `x${(1 + Math.min(2.5, td.spellPressure * 0.2)).toFixed(2)}`;
      els.tdReward.textContent = `${format(rewardPower)} power / ${format(rewardMana)} mana`;
    }

    function render() {
      const mps = getMps();
      els.power.textContent = format(state.power);
      els.totalPower.textContent = format(state.totalPower);
      els.mps.textContent = format(mps);
      const rankData = getArcaneRank(state.totalPower);
      els.rank.textContent = `${rankData.name} (+${Math.round((rankData.buffs.mpsMult - 1) * 100)}% mps / +${Math.round((rankData.buffs.spellPowerMult - 1) * 100)}% spell / -${Math.round((1 - rankData.buffs.manaCostMult) * 100)}% mana cost)`;
      els.equipmentLevelingToggle.checked = state.equipmentLevelingEnabled;
      const progress = levelProgress(state.playerLevel, state.levelProgressPower);
      state.levelBonus = (state.playerLevel - 1) * 0.05;
      els.playerLevel.textContent = `Level ${state.playerLevel}`;
      els.levelProfitBonus.textContent = `+${(state.levelBonus * 100).toFixed(0)}% profit`;
      els.levelProgressFill.style.width = `${(progress.pct * 100).toFixed(2)}%`;
      els.levelProgressText.textContent = `${format(progress.current)} / ${format(progress.needed)} power to next level`;
      const activeSpellKey = selectedSpellKey();
      const activeSpell = activeSpellKey ? spellData[activeSpellKey] : null;
      els.manaMirror.textContent = format(state.mana);
      els.clickGain.textContent = `(+${format(Math.max(1, state.clickPower))} power)`;
      els.activeSpellName.textContent = activeSpell ? activeSpell.name : "No Spell Selected";
      if (activeSpell) {
        els.spellPower.textContent = `+${format(spellPower(activeSpellKey))} power/sec`;
        const remainMs = activeSpellRemainingMs(activeSpellKey);
        els.spellTime.textContent = remainMs > 0 ? `${(remainMs / 1000).toFixed(1)}s remaining` : `${activeSpell.durationSec.toFixed(0)}s duration`;
      } else {
        els.spellPower.textContent = "assign from quickslot";
        els.spellTime.textContent = "ready";
      }

      for (const btn of els.buyToggle.querySelectorAll("button")) {
        btn.classList.toggle("active", Number(btn.dataset.buy) === state.buyAmount);
      }

      renderStructures();
      renderEquipment();
      renderPets();
      renderUpgrades();
      renderQuickslots();
      renderTowerDefense();
      renderAchievements();
      renderLog();
    }

    function gameLoop() {
      const now = Date.now();
      const delta = Math.min((now - state.lastTick) / 1000, 1);
      state.lastTick = now;
      const baseGain = getMps() * delta;
      const spellGain = getActiveSpellPps(now) * delta;
      const gain = baseGain + spellGain;
      state.towerDefense.spellPressure = Math.max(0, state.towerDefense.spellPressure - (delta * 0.075));
      updateTowerDefense(delta);
      if (gain > 0) {
        state.power += gain;
        state.totalPower += gain;
        state.levelProgressPower += gain;
        state.mana += baseGain * 0.25 * getPetModifiers().manaGain;
        grantPetXp((baseGain * 0.0025) + (spellGain * 0.005));
      }
      applyLevelUps();

      autoUnlockAchievements();
      render();
    }


    els.equipmentLevelingToggle.addEventListener("change", () => {
      state.equipmentLevelingEnabled = Boolean(els.equipmentLevelingToggle.checked);
      addLog(`Equipment leveling ${state.equipmentLevelingEnabled ? "enabled" : "disabled"}.`, "warn");
      renderGearModal();
      render();
    });

    els.clickBtn.addEventListener("click", gatherPower);
    els.saveBtn.addEventListener("click", () => saveGame(true));
    els.showAllUpgradesBtn.addEventListener("click", openUpgradeListModal);
    els.closeUpgradeListBtn.addEventListener("click", closeUpgradeListModal);
    els.closeGearModalBtn.addEventListener("click", closeGearModal);
    els.closeSpellSlotModalBtn.addEventListener("click", closeSpellSlotModal);
    els.upgradeListModal.addEventListener("click", (event) => {
      if (event.target === els.upgradeListModal) closeUpgradeListModal();
    });
    els.gearModal.addEventListener("click", (event) => {
      if (event.target === els.gearModal) closeGearModal();
    });
    els.spellSlotModal.addEventListener("click", (event) => {
      if (event.target === els.spellSlotModal) closeSpellSlotModal();
    });
    els.resetBtn.addEventListener("click", () => {
      if (confirm("Reset all progress?")) resetGame();
    });
    els.buyToggle.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLButtonElement)) return;
      const amount = Number(target.dataset.buy);
      if (![1, 10, 25].includes(amount)) return;
      state.buyAmount = amount;
      render();
    });

    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && !els.upgradeListModal.classList.contains("hidden")) {
        closeUpgradeListModal();
        return;
      }

      if (event.key === "Escape" && !els.gearModal.classList.contains("hidden")) {
        closeGearModal();
        return;
      }

      if (event.code === "Space") {
        event.preventDefault();
        castSpell();
        return;
      }

      if (event.code.startsWith("Digit")) {
        const slotNumber = Number(event.code.slice(5));
        if (slotNumber >= 1 && slotNumber <= spellQuickslotCount) {
          event.preventDefault();
          state.activeQuickslot = slotNumber - 1;
          castSpell(state.quickslots[slotNumber - 1]);
          render();
        }
      }
    });

    loadGame();
    render();
    setInterval(gameLoop, 100);
    setInterval(() => saveGame(false), AUTO_SAVE_MS);
  </script>
  </body>
</html>
