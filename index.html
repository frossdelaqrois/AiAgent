<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arcane Idle: Wizard Tower</title>
  <style>
    :root {
      color-scheme: dark;
      --accent: #9f43ff;
      --accent-2: #1fb9ff;
      --gold: #ffcb67;
      --ember: #ff7e36;
      --text: #f7edcf;
      --muted: #c4b58f;
      --ok: #84efbb;
      --warn: #ffd479;
      --danger: #ff7f9e;
      --frame: #3e2a17;
      --frame-edge: #8a6533;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Trebuchet MS", "Segoe UI", system-ui, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 50% 15%, rgba(59, 85, 147, 0.55) 0%, transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(106, 51, 153, 0.4) 0%, transparent 28%),
        radial-gradient(circle at 15% 85%, rgba(163, 87, 28, 0.26) 0%, transparent 28%),
        linear-gradient(180deg, #17131d 0%, #0c0a10 100%);
      padding: 20px;
      letter-spacing: 0.02em;
    }

    .game {
      max-width: 1180px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 18px;
    }

    .panel {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.24)),
        radial-gradient(circle at 30% 0%, rgba(143, 84, 37, 0.25), transparent 35%),
        linear-gradient(180deg, #31241b, #24180f);
      border: 2px solid var(--frame-edge);
      border-radius: 12px;
      padding: 16px;
      backdrop-filter: blur(3px);
      box-shadow:
        inset 0 0 0 2px rgba(19, 12, 7, 0.7),
        0 12px 28px rgba(0, 0, 0, 0.45);
    }

    .wide { grid-column: 1 / -1; }

    h1, h2, h3 {
      margin: 0 0 10px;
      font-family: Georgia, "Times New Roman", serif;
      letter-spacing: 0.04em;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
    }

    h1 {
      font-size: 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .sub {
      color: var(--muted);
      font-size: 1rem;
      margin-bottom: 10px;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .stat {
      background: linear-gradient(180deg, rgba(22, 18, 12, 0.8), rgba(16, 12, 8, 0.94));
      border-radius: 10px;
      padding: 10px;
      border: 1px solid rgba(204, 147, 72, 0.42);
      box-shadow: inset 0 1px 0 rgba(255, 214, 135, 0.2);
    }

    .label { color: var(--muted); font-size: 0.82rem; }
    .value { font-size: 1.2rem; font-weight: 700; }

    button {
      width: 100%;
      border: 1px solid rgba(255, 204, 122, 0.65);
      border-radius: 10px;
      padding: 10px 12px;
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #7428d1, #43137f);
      color: white;
      cursor: pointer;
      font-weight: 700;
      transition: transform 0.08s ease, filter 0.15s ease;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.24),
        0 2px 8px rgba(0, 0, 0, 0.42);
      text-transform: uppercase;
    }

    button:hover:not(:disabled) { filter: brightness(1.08); }
    button:active:not(:disabled) { transform: scale(0.985); }
    button:disabled { cursor: not-allowed; opacity: 0.45; }

    .btn-secondary {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #215389, #15325f);
    }

    .btn-danger {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.12), transparent 40%),
        linear-gradient(135deg, #b6492e, #7f2214);
    }

    .shop {
      display: grid;
      gap: 10px;
      margin-top: 8px;
    }

    .item {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 10px;
      align-items: center;
      background: linear-gradient(180deg, rgba(18, 13, 9, 0.9), rgba(43, 28, 16, 0.75));
      border-radius: 10px;
      border: 1px solid rgba(255, 196, 97, 0.28);
      padding: 10px;
    }

    .item-icon {
      width: 64px;
      height: 64px;
      border-radius: 10px;
      border: 1px solid rgba(255, 216, 147, 0.38);
      object-fit: cover;
      background: rgba(0, 0, 0, 0.35);
      box-shadow: 0 0 12px rgba(143, 67, 255, 0.4);
    }

    .name { font-weight: 700; }
    .meta { color: var(--muted); font-size: 0.85rem; margin-top: 2px; }

    .pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(34, 110, 171, 0.4), rgba(26, 69, 112, 0.8));
      color: #9fddff;
      font-size: 0.8rem;
      margin-left: 4px;
      border: 1px solid rgba(159, 221, 255, 0.35);
    }

    .row { display: flex; gap: 10px; }
    .row button { flex: 1; }

    .buy-toggle {
      display: flex;
      border: 1px solid rgba(255, 202, 125, 0.5);
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
      background: rgba(0, 0, 0, 0.3);
    }

    .buy-toggle button {
      border-radius: 0;
      min-width: 58px;
      background: rgba(23, 14, 9, 0.85);
      font-weight: 600;
    }

    .buy-toggle .active {
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
        linear-gradient(135deg, #8f2adb, #57149d);
    }

    #log {
      height: 170px;
      overflow: auto;
      font-size: 0.9rem;
      background: rgba(8, 8, 8, 0.55);
      border-radius: 10px;
      padding: 8px;
      border: 1px solid rgba(255, 192, 106, 0.33);
      margin-top: 10px;
    }

    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
    .danger { color: var(--danger); }

    .tiny { font-size: 0.8rem; color: var(--muted); margin-top: 10px; }

    .resource-strips {
      margin-top: 12px;
      display: grid;
      gap: 8px;
    }

    .resource {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 233, 181, 0.35);
      background: linear-gradient(135deg, rgba(36, 22, 12, 0.95), rgba(59, 37, 21, 0.75));
      font-weight: 700;
    }

    .resource b {
      color: var(--gold);
    }


    .spell-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .spell-card {
      display: grid;
      gap: 8px;
      background: linear-gradient(180deg, rgba(16, 10, 6, 0.95), rgba(42, 22, 44, 0.7));
      border: 1px solid rgba(170, 127, 255, 0.48);
      border-radius: 12px;
      padding: 10px;
    }

    .spell-head {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .spell-icon {
      width: 58px;
      height: 58px;
      border-radius: 12px;
      border: 1px solid rgba(186, 225, 255, 0.55);
      box-shadow: 0 0 12px rgba(79, 174, 255, 0.45);
      background: rgba(0,0,0,0.35);
    }

    .spell-mini {
      font-size: 0.78rem;
      color: var(--muted);
    }

    @media (max-width: 900px) {
      .game { grid-template-columns: 1fr; }
      .stats { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>
<body>
  <main class="game">
    <section class="panel wide">
      <h1>
        <span>üßô Arcane Idle: Wizard Tower</span>
        <span class="pill">Idle + Clicker</span>
      </h1>
      <div class="sub">Gather mana, train apprentices, and automate your magical empire with a richer fantasy HUD.</div>
      <div class="row">
        <button id="castBtn">‚ú® Cast <span id="activeSpellName">Arcane Bolt</span> (<span id="spellPower">+1</span>)</button>
        <button id="saveBtn" class="btn-secondary">üíæ Save</button>
        <button id="resetBtn" class="btn-danger">‚ôªÔ∏è Reset</button>
      </div>
      <div class="stats">
        <div class="stat"><div class="label">Mana</div><div class="value" id="mana">0</div></div>
        <div class="stat"><div class="label">Mana / sec</div><div class="value" id="mps">0</div></div>
        <div class="stat"><div class="label">Arcane Rank</div><div class="value" id="rank">Novice</div></div>
        <div class="stat"><div class="label">Total Mana Ever</div><div class="value" id="totalMana">0</div></div>
        <div class="stat"><div class="label">Autosave</div><div class="value" id="saveState">Ready</div></div>
        <div class="stat"><div class="label">Buy Amount</div><div class="value" id="buyAmountLabel">x1</div></div>
      </div>
      <div class="resource-strips">
        <div class="resource"><span>ü™ô Gold Reserve</span><b id="goldMirror">0</b></div>
        <div class="resource"><span>üî∑ Mana Pool</span><b id="manaMirror">0</b></div>
        <div class="resource"><span>üíú Arcane Crystal Stock</span><b id="crystalMirror">0</b></div>
      </div>
      <div class="tiny">Tip: Press <strong>spacebar</strong> to cast your selected spell quickly.</div>
    </section>

    <section class="panel">
      <h2>üß™ Structures</h2>
      <div class="buy-toggle" id="buyToggle">
        <button data-buy="1" class="active">x1</button>
        <button data-buy="10">x10</button>
        <button data-buy="25">x25</button>
      </div>
      <div id="structures" class="shop"></div>
    </section>


    <section class="panel">
      <h2>‚öîÔ∏è Spells</h2>
      <div id="spells" class="spell-grid"></div>
    </section>

    <section class="panel">
      <h2>üîÆ Upgrades</h2>
      <div id="upgrades" class="shop"></div>
      <h3 style="margin-top: 16px;">üèÜ Achievements</h3>
      <div id="achievements" class="shop"></div>
    </section>

    <section class="panel wide">
      <h2>üìú Event Log</h2>
      <div id="log"></div>
    </section>
  </main>

  <script>
    const STORAGE_KEY = "arcane-idle-save-v2";
    const AUTO_SAVE_MS = 20000;


    function svgIcon(label, colorA, colorB, glyph) {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96" role="img" aria-label="${label}">`
        + `<defs><linearGradient id="g" x1="0" x2="1" y1="0" y2="1"><stop offset="0%" stop-color="${colorA}"/><stop offset="100%" stop-color="${colorB}"/></linearGradient><radialGradient id="r" cx="50%" cy="40%" r="60%"><stop offset="0%" stop-color="#ffffff" stop-opacity="0.35"/><stop offset="100%" stop-color="#000000" stop-opacity="0"/></radialGradient></defs>`
        + `<rect x="3" y="3" width="90" height="90" rx="18" fill="url(#g)"/>`
        + `<rect x="7" y="7" width="82" height="82" rx="14" fill="url(#r)"/>`
        + `<circle cx="48" cy="48" r="33" fill="rgba(8,8,18,0.3)"/>`
        + `<text x="48" y="59" text-anchor="middle" font-size="38" font-family="Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji, sans-serif">${glyph}</text>`
        + `</svg>`;
      return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
    }

    const structureData = {
      apprentice: { name: "Apprentice", baseCost: 15, mps: 0.6, growth: 1.15, image: svgIcon("Apprentice", "#7852ff", "#4ec0ff", "üßô"), tooltip: "Apprentices channel basic mana streams and are your first source of passive mana income." },
      crystal: { name: "Mana Crystal", baseCost: 100, mps: 4, growth: 1.16, image: svgIcon("Mana Crystal", "#6f58ff", "#3cc4f4", "üî∑"), tooltip: "Mana Crystals store ambient arcane power to sharply increase mana per second." },
      library: { name: "Enchanted Library", baseCost: 550, mps: 22, growth: 1.18, image: svgIcon("Enchanted Library", "#9362ff", "#4cc6a8", "üìö"), tooltip: "Enchanted Libraries unlock efficient spellcraft methods that multiply your idle gains." },
      golem: { name: "Arcane Golem", baseCost: 2600, mps: 95, growth: 1.2, image: svgIcon("Arcane Golem", "#8a6a55", "#4a7aa3", "üóø"), tooltip: "Arcane Golems automate heavy magical labor and massively boost production." },
      observatory: { name: "Astral Observatory", baseCost: 11000, mps: 440, growth: 1.23, image: svgIcon("Astral Observatory", "#4b4f9f", "#51bde8", "üî≠"), tooltip: "Astral Observatories align your tower with leylines for elite mana generation." },
      manaForge: { name: "Mana Forge", baseCost: 42000, mps: 1650, growth: 1.24, image: svgIcon("Mana Forge", "#ff8d39", "#c93624", "üî•"), tooltip: "A blazing forge that condenses raw arcana into high-output power cores." },
      portalNexus: { name: "Portal Nexus", baseCost: 140000, mps: 5200, growth: 1.26, image: svgIcon("Portal Nexus", "#1e89e8", "#7f35e6", "üåÄ"), tooltip: "Portal arrays siphon mana from nearby dimensions." },
      skyCitadel: { name: "Sky Citadel", baseCost: 420000, mps: 18000, growth: 1.27, image: svgIcon("Sky Citadel", "#4cb2ff", "#a676ff", "üè∞"), tooltip: "Floating mage-citadels create massive autonomous arcane output." },
      voidReactor: { name: "Void Reactor", baseCost: 1300000, mps: 63000, growth: 1.29, image: svgIcon("Void Reactor", "#6233bd", "#1b0f40", "üåå"), tooltip: "Harnesses dark-space turbulence for late-game production spikes." },
    };

        const upgradeData = {
      focusedWand: {
        name: "Focused Wand",
        cost: 60,
        effect: "Double Arcane Bolt power",
        image: svgIcon("Focused Wand", "#7a5cff", "#36a7ff", "ü™Ñ"),
        tooltip: "Focused Wand strengthens each manual cast, making every click worth twice as much mana.",
        apply: (state) => state.clickPower *= 2,
      },
      dualChanneling: {
        name: "Dual Channeling",
        cost: 450,
        effect: "Arcane Bolt gains +8 power",
        image: svgIcon("Dual Channeling", "#8f62ff", "#46c0f8", "‚ú®"),
        tooltip: "Dual Channeling weaves two spells at once so each cast adds a large flat mana bonus.",
        apply: (state) => state.clickPower += 8,
      },
      runeEtching: {
        name: "Rune Etching",
        cost: 1200,
        effect: "All spell power +30%",
        image: svgIcon("Rune Etching", "#ad6cff", "#4ed8ff", "‚ú¥Ô∏è"),
        tooltip: "Arcane runes amplify the impact of every offensive cast.",
        apply: () => {},
      },
      manaCompression: {
        name: "Mana Compression",
        cost: 4200,
        effect: "Spell costs -20%",
        image: svgIcon("Mana Compression", "#1f95ff", "#7044ff", "üßø"),
        tooltip: "Dense mana channels reduce the mana needed to cast heavy spells.",
        apply: () => {},
      },
      leylineBinding: {
        name: "Leyline Binding",
        cost: 1400,
        effect: "All structures produce +25% mana",
        image: svgIcon("Leyline Binding", "#4d75d4", "#5ecf95", "üï∏Ô∏è"),
        tooltip: "Leyline Binding anchors your tower to nearby leylines, increasing all structure output.",
        apply: () => {},
      },
      crystallizedThought: {
        name: "Crystallized Thought",
        cost: 6000,
        effect: "All structures produce +50% mana",
        image: svgIcon("Crystallized Thought", "#5e7ad0", "#86dbff", "üíé"),
        tooltip: "Crystallized Thought refines magical focus, delivering a major global boost to structures.",
        apply: () => {},
      },
      archmageSigil: {
        name: "Archmage Sigil",
        cost: 26000,
        effect: "All structures produce +120% mana",
        image: svgIcon("Archmage Sigil", "#ffcd65", "#7b39ff", "üúÇ"),
        tooltip: "An ancient sigil that supercharges every mana engine in your empire.",
        apply: () => {},
      },
      tempestMastery: {
        name: "Tempest Mastery",
        cost: 90000,
        effect: "Lightning and Meteor spells +90% power",
        image: svgIcon("Tempest Mastery", "#29a7ff", "#f0bb5e", "‚ö°"),
        tooltip: "Mastery over storm magic dramatically boosts high-tier burst spells.",
        apply: () => {},
      },
    };

        const spellData = {
      bolt: { name: "Arcane Bolt", basePower: 1, manaCost: 0, unlockAt: 0, image: svgIcon("Arcane Bolt", "#6f53ff", "#4ec6ff", "‚ú®") },
      fireball: { name: "Fireball", basePower: 40, manaCost: 30, unlockAt: 300, image: svgIcon("Fireball", "#ff8f3f", "#b71e16", "üî•") },
      lightning: { name: "Chain Lightning", basePower: 175, manaCost: 120, unlockAt: 2500, image: svgIcon("Chain Lightning", "#35b6ff", "#5868ff", "‚ö°") },
      meteor: { name: "Meteor Strike", basePower: 800, manaCost: 620, unlockAt: 14000, image: svgIcon("Meteor Strike", "#ffd36f", "#ff622f", "‚òÑÔ∏è") },
      voidburst: { name: "Void Burst", basePower: 3200, manaCost: 2600, unlockAt: 70000, image: svgIcon("Void Burst", "#4f2d89", "#0f0627", "üï≥Ô∏è") },
    };

    const achievementData = [
      { key: "mana1k", name: "Mana Hoarder I", image: svgIcon("Mana Hoarder I", "#4f69d9", "#57c8f2", "ü•â"), test: (s) => s.totalMana >= 1000, requirement: "Accumulate 1,000 total mana from any source.", reward: "+5% structure output", tooltip: "First hoarding milestone. Keep casting and buying structures until lifetime mana hits 1,000." },
      { key: "mana20k", name: "Mana Hoarder II", image: svgIcon("Mana Hoarder II", "#6f62d0", "#58d4d2", "ü•à"), test: (s) => s.totalMana >= 20000, requirement: "Accumulate 20,000 total mana over the run.", reward: "+10% structure output", tooltip: "Advanced hoarding milestone. Scale production and idle income to reach 20,000 lifetime mana." },
      { key: "golem3", name: "Golem Battalion", image: svgIcon("Golem Battalion", "#7c5e90", "#4ca2c2", "üèÖ"), test: (s) => s.structures.golem >= 3, requirement: "Own 3 Arcane Golems at the same time.", reward: "+15 click power", tooltip: "Construct three Arcane Golems to earn this badge and permanently strengthen manual casting." },
    ];

    const state = {
      mana: 0,
      totalMana: 0,
      clickPower: 1,
      buyAmount: 1,
      activeSpell: "bolt",
      spellCasts: 0,
      structures: Object.fromEntries(Object.keys(structureData).map((k) => [k, 0])),
      upgrades: Object.fromEntries(Object.keys(upgradeData).map((k) => [k, false])),
      achievements: Object.fromEntries(achievementData.map((a) => [a.key, false])),
      lastTick: Date.now(),
      lastSavedAt: null,
      log: [{ text: "Welcome, wizard. Your tower awaits.", klass: "" }],
    };

    const els = {
      mana: document.getElementById("mana"),
      totalMana: document.getElementById("totalMana"),
      mps: document.getElementById("mps"),
      rank: document.getElementById("rank"),
      clickPower: document.getElementById("clickPower"),
      saveState: document.getElementById("saveState"),
      buyAmountLabel: document.getElementById("buyAmountLabel"),
      goldMirror: document.getElementById("goldMirror"),
      manaMirror: document.getElementById("manaMirror"),
      crystalMirror: document.getElementById("crystalMirror"),
      activeSpellName: document.getElementById("activeSpellName"),
      spellPower: document.getElementById("spellPower"),
      castBtn: document.getElementById("castBtn"),
      spells: document.getElementById("spells"),
      saveBtn: document.getElementById("saveBtn"),
      resetBtn: document.getElementById("resetBtn"),
      buyToggle: document.getElementById("buyToggle"),
      structures: document.getElementById("structures"),
      upgrades: document.getElementById("upgrades"),
      achievements: document.getElementById("achievements"),
      log: document.getElementById("log"),
    };

    function format(num) {
      if (num < 1000) return num.toFixed(1).replace(/\.0$/, "");
      const units = ["K", "M", "B", "T", "Qa", "Qi"];
      let value = num;
      let idx = -1;
      while (value >= 1000 && idx < units.length - 1) {
        value /= 1000;
        idx += 1;
      }
      return `${value.toFixed(2)}${units[idx]}`;
    }

    function rankFromMana(totalMana) {
      if (totalMana >= 1200000) return "Grand Archmage";
      if (totalMana >= 300000) return "Archmage";
      if (totalMana >= 90000) return "Master";
      if (totalMana >= 20000) return "Adept";
      if (totalMana >= 3000) return "Scholar";
      if (totalMana >= 400) return "Initiate";
      return "Novice";
    }

    function addLog(message, klass = "") {
      const stamped = `[${new Date().toLocaleTimeString()}] ${message}`;
      state.log.unshift({ text: stamped, klass });
      state.log = state.log.slice(0, 90);
    }

    function getStructureCost(key, levelOffset = 0) {
      const data = structureData[key];
      const level = state.structures[key] + levelOffset;
      return Math.floor(data.baseCost * Math.pow(data.growth, level));
    }

    function getBulkStructureCost(key, amount) {
      let total = 0;
      for (let i = 0; i < amount; i += 1) {
        total += getStructureCost(key, i);
      }
      return total;
    }

    function productionMultiplier() {
      let mult = 1;
      if (state.upgrades.leylineBinding) mult *= 1.25;
      if (state.upgrades.crystallizedThought) mult *= 1.5;
      if (state.upgrades.archmageSigil) mult *= 2.2;
      if (state.achievements.mana1k) mult *= 1.05;
      if (state.achievements.mana20k) mult *= 1.1;
      return mult;
    }

    function getMps() {
      let total = 0;
      for (const [key, amount] of Object.entries(state.structures)) {
        total += amount * structureData[key].mps;
      }
      return total * productionMultiplier();
    }


    function spellCost(key) {
      const base = spellData[key].manaCost;
      const reduction = state.upgrades.manaCompression ? 0.8 : 1;
      return Math.floor(base * reduction);
    }

    function spellPower(key) {
      let power = spellData[key].basePower;
      if (key === "bolt") power = Math.max(power, state.clickPower);
      if (state.upgrades.runeEtching) power *= 1.3;
      if (state.upgrades.tempestMastery && (key === "lightning" || key === "meteor")) power *= 1.9;
      return power;
    }

    function isSpellUnlocked(key) {
      return state.totalMana >= spellData[key].unlockAt;
    }

    function canAfford(cost) {
      return state.mana >= cost;
    }

    function buyStructure(key) {
      const amount = state.buyAmount;
      const totalCost = getBulkStructureCost(key, amount);
      if (!canAfford(totalCost)) return;

      state.mana -= totalCost;
      state.structures[key] += amount;
      addLog(`Purchased ${amount} ${structureData[key].name}${amount > 1 ? "s" : ""}.`, "ok");
      checkAchievements();
      render();
    }

    function buyUpgrade(key) {
      const up = upgradeData[key];
      if (state.upgrades[key] || !canAfford(up.cost)) return;
      state.mana -= up.cost;
      state.upgrades[key] = true;
      up.apply(state);
      addLog(`Learned upgrade: ${up.name}. ${up.effect}`, "ok");
      render();
    }

    function unlockAchievement(key) {
      if (state.achievements[key]) return;
      state.achievements[key] = true;
      const achievement = achievementData.find((a) => a.key === key);
      if (key === "golem3") state.clickPower += 15;
      addLog(`Achievement unlocked: ${achievement.name} (${achievement.reward})`, "ok");
    }

    function checkAchievements() {
      for (const achievement of achievementData) {
        if (!state.achievements[achievement.key] && achievement.test(state)) {
          unlockAchievement(achievement.key);
        }
      }
    }

    function castSpell(spellKey = state.activeSpell) {
      const key = spellData[spellKey] ? spellKey : "bolt";
      if (!isSpellUnlocked(key)) return;
      const cost = spellCost(key);
      if (state.mana < cost) return;

      const power = spellPower(key);
      state.mana -= cost;
      state.mana += power;
      state.totalMana += power;
      state.spellCasts += 1;
      if (state.spellCasts % 25 === 0) {
        addLog(`Arcane rhythm! ${state.spellCasts} spells cast so far.`, "warn");
      }
      checkAchievements();
      render();
    }

    function saveGame(showToast = true) {
      const payload = { ...state, lastTick: Date.now(), log: state.log.slice(0, 60) };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      state.lastSavedAt = Date.now();
      if (showToast) addLog("Game saved.", "ok");
      render();
    }

    function normalizeLoadedState(data) {
      state.mana = Number(data.mana || 0);
      state.totalMana = Number(data.totalMana || 0);
      state.clickPower = Number(data.clickPower || 1);
      state.buyAmount = [1, 10, 25].includes(Number(data.buyAmount)) ? Number(data.buyAmount) : 1;
      state.activeSpell = typeof data.activeSpell === "string" && spellData[data.activeSpell] ? data.activeSpell : "bolt";
      state.spellCasts = Number(data.spellCasts || 0);

      for (const key of Object.keys(state.structures)) {
        state.structures[key] = Number(data.structures?.[key] || 0);
      }
      for (const key of Object.keys(state.upgrades)) {
        state.upgrades[key] = Boolean(data.upgrades?.[key]);
      }
      for (const key of Object.keys(state.achievements)) {
        state.achievements[key] = Boolean(data.achievements?.[key]);
      }

      state.log = Array.isArray(data.log) && data.log.length
        ? data.log.map((entry) => (typeof entry === "string" ? { text: entry, klass: "" } : entry))
        : [{ text: "Welcome back, wizard.", klass: "" }];
    }

    function applyOfflineProgress(previousTick) {
      if (!previousTick) return;
      const elapsedSeconds = Math.min((Date.now() - previousTick) / 1000, 6 * 60 * 60);
      if (elapsedSeconds <= 2) return;
      const gained = getMps() * elapsedSeconds;
      if (gained <= 0) return;

      state.mana += gained;
      state.totalMana += gained;
      addLog(`You were away for ${Math.floor(elapsedSeconds)}s and gained ${format(gained)} mana.`, "warn");
    }

    function loadGame() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;

      try {
        const parsed = JSON.parse(raw);
        const previousTick = Number(parsed.lastTick);
        normalizeLoadedState(parsed);
        applyOfflineProgress(previousTick);
        state.lastTick = Date.now();
        addLog("Save loaded.", "ok");
      } catch {
        addLog("Save file corrupted. Starting fresh.", "danger");
      }
    }

    function resetGame() {
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    }

    function renderStructures() {
      els.structures.innerHTML = "";
      for (const [key, data] of Object.entries(structureData)) {
        const owned = state.structures[key];
        const nextCost = getStructureCost(key, 0);
        const bulkCost = getBulkStructureCost(key, state.buyAmount);
        const disabled = !canAfford(bulkCost);

        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${data.image}" alt="${data.name} icon" title="${data.tooltip}" />
          <div>
            <div class="name">${data.name} <span class="pill">Owned: ${owned}</span></div>
            <div class="meta">+${format(data.mps)}/sec each ‚Ä¢ Next: ${format(nextCost)} mana</div>
            <div class="meta">Buy ${state.buyAmount}: ${format(bulkCost)} mana</div>
          </div>
          <button ${disabled ? "disabled" : ""}>Buy x${state.buyAmount}</button>
        `;

        card.querySelector("button").onclick = () => buyStructure(key);
        els.structures.appendChild(card);
      }
    }

    function renderUpgrades() {
      els.upgrades.innerHTML = "";
      for (const [key, up] of Object.entries(upgradeData)) {
        const unlocked = state.upgrades[key];
        const disabled = unlocked || !canAfford(up.cost);
        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${up.image}" alt="${up.name} icon" title="${up.tooltip}" />
          <div>
            <div class="name">${up.name} ${unlocked ? '<span class="pill">Learned</span>' : ""}</div>
            <div class="meta">${up.effect} ‚Ä¢ Cost: ${format(up.cost)} mana</div>
          </div>
          <button ${disabled ? "disabled" : ""}>${unlocked ? "Done" : "Research"}</button>
        `;
        card.querySelector("button").onclick = () => buyUpgrade(key);
        els.upgrades.appendChild(card);
      }
    }

    function renderSpells() {
      els.spells.innerHTML = "";
      for (const [key, spell] of Object.entries(spellData)) {
        const unlocked = isSpellUnlocked(key);
        const selected = state.activeSpell === key;
        const cost = spellCost(key);
        const power = spellPower(key);

        const card = document.createElement("div");
        card.className = "spell-card";
        card.innerHTML = `
          <div class="spell-head">
            <img class="spell-icon" src="${spell.image}" alt="${spell.name} icon" />
            <div>
              <div class="name">${spell.name} ${selected ? '<span class="pill">Selected</span>' : ''}</div>
              <div class="spell-mini">Power: +${format(power)} mana</div>
              <div class="spell-mini">Cost: ${format(cost)} mana</div>
            </div>
          </div>
          <div class="row">
            <button ${unlocked ? "" : "disabled"} data-action="select">${selected ? "Selected" : "Select"}</button>
            <button ${(!unlocked || !canAfford(cost)) ? "disabled" : ""} data-action="cast">Cast</button>
          </div>
        `;

        card.querySelector('[data-action="select"]').onclick = () => { state.activeSpell = key; render(); };
        card.querySelector('[data-action="cast"]').onclick = () => castSpell(key);
        if (!unlocked) {
          const req = document.createElement("div");
          req.className = "spell-mini";
          req.textContent = `Unlock at total mana: ${format(spell.unlockAt)}`;
          card.appendChild(req);
        }
        els.spells.appendChild(card);
      }
    }

    function renderAchievements() {
      els.achievements.innerHTML = "";
      for (const achievement of achievementData) {
        const unlocked = state.achievements[achievement.key];
        const card = document.createElement("div");
        card.className = "item";
        card.innerHTML = `
          <img class="item-icon" src="${achievement.image}" alt="${achievement.name} icon" title="${achievement.tooltip}" />
          <div>
            <div class="name">${achievement.name} ${unlocked ? '<span class="pill">Unlocked</span>' : ""}</div>
            <div class="meta">How to unlock: ${achievement.requirement}</div>
            <div class="meta">Reward: ${achievement.reward}</div>
          </div>
          <button disabled>${unlocked ? "Done" : "Locked"}</button>
        `;
        els.achievements.appendChild(card);
      }
    }

    function renderLog() {
      els.log.innerHTML = state.log
        .map((entry) => `<div class="${entry.klass || ""}">${entry.text}</div>`)
        .join("");
    }

    function render() {
      const mps = getMps();
      els.mana.textContent = format(state.mana);
      els.totalMana.textContent = format(state.totalMana);
      els.mps.textContent = format(mps);
      els.rank.textContent = rankFromMana(state.totalMana);
      const activeSpell = spellData[state.activeSpell] || spellData.bolt;
      els.clickPower.textContent = format(state.clickPower);
      els.buyAmountLabel.textContent = `x${state.buyAmount}`;
      els.goldMirror.textContent = format(state.totalMana * 0.42 + 150);
      els.manaMirror.textContent = format(state.mana);
      els.crystalMirror.textContent = format(state.totalMana / 8 + Object.values(state.upgrades).filter(Boolean).length * 25);
      els.activeSpellName.textContent = activeSpell.name;
      els.spellPower.textContent = `+${format(spellPower(state.activeSpell))} mana`;

      if (state.lastSavedAt) {
        const age = Math.max(0, Math.floor((Date.now() - state.lastSavedAt) / 1000));
        els.saveState.textContent = `${age}s ago`;
      } else {
        els.saveState.textContent = "Not saved";
      }

      for (const btn of els.buyToggle.querySelectorAll("button")) {
        btn.classList.toggle("active", Number(btn.dataset.buy) === state.buyAmount);
      }

      renderStructures();
      renderUpgrades();
      renderSpells();
      renderAchievements();
      renderLog();
    }

    function gameLoop() {
      const now = Date.now();
      const delta = Math.min((now - state.lastTick) / 1000, 1);
      state.lastTick = now;
      const gain = getMps() * delta;
      if (gain > 0) {
        state.mana += gain;
        state.totalMana += gain;
        checkAchievements();
      }
      render();
    }

    els.castBtn.addEventListener("click", castSpell);
    els.saveBtn.addEventListener("click", () => saveGame(true));
    els.resetBtn.addEventListener("click", () => {
      if (confirm("Reset all progress?")) resetGame();
    });
    els.buyToggle.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLButtonElement)) return;
      const amount = Number(target.dataset.buy);
      if (![1, 10, 25].includes(amount)) return;
      state.buyAmount = amount;
      render();
    });

    window.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        event.preventDefault();
        castSpell();
      }
    });

    loadGame();
    render();
    setInterval(gameLoop, 200);
    setInterval(() => saveGame(false), AUTO_SAVE_MS);
  </script>
</body>
</html>
